

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>alogos._grammar.parsing.io_with_regex &mdash; alogos 0.2.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html">
          

          
            
            <img src="../../../../_static/alogos.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/package_references.html">Package References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/quickstart.html">Quickstart Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/getting_started.html">Getting Started Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst/examples.html">Code Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../autoapi/index.html">API Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">alogos</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>alogos._grammar.parsing.io_with_regex</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for alogos._grammar.parsing.io_with_regex</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">re</span> <span class="k">as</span> <span class="nn">_re</span>

<span class="kn">from</span> <span class="nn">...</span> <span class="kn">import</span> <span class="n">exceptions</span> <span class="k">as</span> <span class="n">_exceptions</span>
<span class="kn">from</span> <span class="nn">...</span> <span class="kn">import</span> <span class="n">warnings</span> <span class="k">as</span> <span class="n">_warnings</span>
<span class="kn">from</span> <span class="nn">..._utilities</span> <span class="kn">import</span> <span class="n">argument_processing</span> <span class="k">as</span> <span class="n">_ap</span>
<span class="kn">from</span> <span class="nn">..._utilities.operating_system</span> <span class="kn">import</span> <span class="n">NEWLINE</span> <span class="k">as</span> <span class="n">_NEWLINE</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">data_structures</span> <span class="k">as</span> <span class="n">_data_structures</span>


<span class="c1"># Shared regex patterns</span>
<span class="c1"># - Letter followed by arbitrary sequence of letters, digits, _ and -</span>
<span class="n">_STANDALONE_NONTERMINAL_PATTERN</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[a-zA-Z][-_0-9a-zA-Z]*&quot;</span>

<span class="c1"># - Sequence of non-whitespace symbols</span>
<span class="n">_STANDALONE_TERMINAL_PATTERN</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[^\s]+&quot;</span>

<span class="c1"># - Shortest possible sequence of symbols and newline (until first end mark is found)</span>
<span class="n">_ENCLOSED_NONTERMINAL_PATTERN</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.+?&quot;</span>
<span class="n">_ENCLOSED_TERMINAL_PATTERN</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:.|</span><span class="si">{newline}</span><span class="s2">)*?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">newline</span><span class="o">=</span><span class="n">_NEWLINE</span><span class="p">)</span>

<span class="c1"># - Longest possible sequence of whitespaces including empty (space, tab, newline, linefeed, etc.)</span>
<span class="n">_MAX_OPT_WHITESPACE</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s*&quot;</span>

<span class="c1"># Suffix for naming rules derived in automatic EBNF to BNF conversion</span>
<span class="n">_SHARED_SUFFIX</span> <span class="o">=</span> <span class="s2">&quot;_ยง&quot;</span>


<span class="c1"># Reading BNF and EBNF</span>


<div class="viewcode-block" id="read_bnf"><a class="viewcode-back" href="../../../../autoapi/alogos/_grammar/parsing/io_with_regex/index.html#alogos._grammar.parsing.read_bnf">[docs]</a><span class="k">def</span> <span class="nf">read_bnf</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">bnf_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read grammar from text in BNF notation.&quot;&quot;&quot;</span>
    <span class="c1"># Argument processing</span>
    <span class="n">bnf_text</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;bnf_text&quot;</span><span class="p">,</span> <span class="n">bnf_text</span><span class="p">)</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">bool_arg</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">def_symbol</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="p">,</span>
        <span class="n">start_nt</span><span class="p">,</span>
        <span class="n">end_nt</span><span class="p">,</span>
        <span class="n">start_t1</span><span class="p">,</span>
        <span class="n">end_t1</span><span class="p">,</span>
        <span class="n">start_t2</span><span class="p">,</span>
        <span class="n">end_t2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_check_symbols_validity</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>

    <span class="c1"># Conversion of user-provided symbols into escaped strings for secure use in regex patterns</span>
    <span class="n">esc_def_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">def_symbol</span><span class="p">)</span>
    <span class="n">esc_start_nt</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_nt</span><span class="p">)</span>
    <span class="n">esc_end_nt</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_nt</span><span class="p">)</span>
    <span class="n">esc_start_t1</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_t1</span><span class="p">)</span>
    <span class="n">esc_end_t1</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_t1</span><span class="p">)</span>
    <span class="n">esc_start_t2</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_t2</span><span class="p">)</span>
    <span class="n">esc_end_t2</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_t2</span><span class="p">)</span>

    <span class="c1"># Print arguments</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">represent</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Empty string&quot;</span> <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">text</span>

        <span class="n">heading</span> <span class="o">=</span> <span class="s2">&quot;Used symbols&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">heading</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">heading</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;defining_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">def_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rule_separator_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">rule_separator_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_nonterminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_nt</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_nonterminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_nt</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_terminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_t1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_terminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_t1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_terminal_symbol2:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_t2</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_terminal_symbol2:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_t2</span><span class="p">))</span>

    <span class="c1"># Parsing step 1: Split full text into list of lhs (=nonterminal) and rhs (=other symbols)</span>
    <span class="c1"># 1.a) Regex pattern preparation</span>
    <span class="k">if</span> <span class="n">start_nt</span> <span class="ow">and</span> <span class="n">end_nt</span><span class="p">:</span>
        <span class="n">pattern_nt</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">esc_start_nt</span><span class="p">,</span> <span class="n">_ENCLOSED_NONTERMINAL_PATTERN</span><span class="p">,</span> <span class="n">esc_end_nt</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pattern_nt</span> <span class="o">=</span> <span class="n">_STANDALONE_NONTERMINAL_PATTERN</span>
    <span class="n">pattern_lhs_rhs</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{newline}{ws}</span><span class="s2">(</span><span class="si">{nonterminal}</span><span class="s2">)</span><span class="si">{ws}{defsymbol}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">newline</span><span class="o">=</span><span class="n">_NEWLINE</span><span class="p">,</span>
        <span class="n">ws</span><span class="o">=</span><span class="n">_MAX_OPT_WHITESPACE</span><span class="p">,</span>
        <span class="n">nonterminal</span><span class="o">=</span><span class="n">pattern_nt</span><span class="p">,</span>
        <span class="n">defsymbol</span><span class="o">=</span><span class="n">esc_def_symbol</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">re_lhs_rhs</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern_lhs_rhs</span><span class="p">)</span>
    <span class="n">bnf_text</span> <span class="o">=</span> <span class="n">_NEWLINE</span> <span class="o">+</span> <span class="n">bnf_text</span>  <span class="c1"># newline to guarantee recognition of the first lhs</span>

    <span class="c1"># 1.b) Parsing</span>
    <span class="n">txt_list_lhs_rhs</span> <span class="o">=</span> <span class="n">re_lhs_rhs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">bnf_text</span><span class="p">)</span>
    <span class="n">txt_list_lhs_rhs</span> <span class="o">=</span> <span class="n">txt_list_lhs_rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># get rid of an empty first match</span>

    <span class="c1"># Parsing step 2: Finding the single nonterminal symbol in lhs and arbitrary symbols in rhs</span>
    <span class="c1"># 2.a) Helper functions</span>
    <span class="k">def</span> <span class="nf">create_enclosed_symbol_pattern</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">crop_symbol</span><span class="p">(</span><span class="n">txt_sym</span><span class="p">,</span> <span class="n">txt_start</span><span class="p">,</span> <span class="n">txt_end</span><span class="p">):</span>
        <span class="n">idx_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_start</span><span class="p">)</span>
        <span class="n">idx_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_sym</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">txt_sym</span><span class="p">[</span><span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">text_is_a_nonterminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re_nt</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">text_is_a_terminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re_t</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_a_nonterminal</span><span class="p">(</span><span class="n">txt_nt_enclosed</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
            <span class="n">txt_nt</span> <span class="o">=</span> <span class="n">crop_symbol</span><span class="p">(</span><span class="n">txt_nt_enclosed</span><span class="p">,</span> <span class="n">start_nt</span><span class="p">,</span> <span class="n">end_nt</span><span class="p">)</span>
        <span class="n">sym_nt</span> <span class="o">=</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">NonterminalSymbol</span><span class="p">(</span><span class="n">txt_nt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sym_nt</span>

    <span class="k">def</span> <span class="nf">process_a_terminal</span><span class="p">(</span><span class="n">txt_t_enclosed</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">txt_t_enclosed</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">start_t1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">txt_t_enclosed</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">end_t1</span><span class="p">):</span>
            <span class="n">txt_t</span> <span class="o">=</span> <span class="n">crop_symbol</span><span class="p">(</span><span class="n">txt_t_enclosed</span><span class="p">,</span> <span class="n">start_t1</span><span class="p">,</span> <span class="n">end_t1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt_t</span> <span class="o">=</span> <span class="n">crop_symbol</span><span class="p">(</span><span class="n">txt_t_enclosed</span><span class="p">,</span> <span class="n">start_t2</span><span class="p">,</span> <span class="n">end_t2</span><span class="p">)</span>
        <span class="n">sym_t</span> <span class="o">=</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">TerminalSymbol</span><span class="p">(</span><span class="n">txt_t</span><span class="p">)</span>
        <span class="n">_add_terminal_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym_t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sym_t</span>

    <span class="c1"># 2.b) Regex pattern preparation</span>
    <span class="c1"># Nonterminal symbols</span>
    <span class="n">pattern_nt</span> <span class="o">=</span> <span class="n">create_enclosed_symbol_pattern</span><span class="p">(</span>
        <span class="n">esc_start_nt</span><span class="p">,</span> <span class="n">_ENCLOSED_NONTERMINAL_PATTERN</span><span class="p">,</span> <span class="n">esc_end_nt</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">pattern_nt</span><span class="p">:</span>
        <span class="n">re_nt</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern_nt</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">re_nt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Terminal symbols</span>
    <span class="n">pattern_t1</span> <span class="o">=</span> <span class="n">create_enclosed_symbol_pattern</span><span class="p">(</span>
        <span class="n">esc_start_t1</span><span class="p">,</span> <span class="n">_ENCLOSED_TERMINAL_PATTERN</span><span class="p">,</span> <span class="n">esc_end_t1</span>
    <span class="p">)</span>
    <span class="n">pattern_t2</span> <span class="o">=</span> <span class="n">create_enclosed_symbol_pattern</span><span class="p">(</span>
        <span class="n">esc_start_t2</span><span class="p">,</span> <span class="n">_ENCLOSED_TERMINAL_PATTERN</span><span class="p">,</span> <span class="n">esc_end_t2</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">pattern_t1</span> <span class="ow">and</span> <span class="n">pattern_t2</span><span class="p">:</span>
        <span class="n">re_t</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">pattern_t1</span><span class="p">,</span> <span class="n">pattern_t2</span><span class="p">])))</span>
    <span class="k">elif</span> <span class="n">pattern_t1</span><span class="p">:</span>
        <span class="n">re_t</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern_t1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">re_t</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Right-hand sides</span>
    <span class="n">pattern_nonempty</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">pat</span> <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">pattern_nt</span><span class="p">,</span> <span class="n">pattern_t1</span><span class="p">,</span> <span class="n">pattern_t2</span><span class="p">]</span> <span class="k">if</span> <span class="n">pat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">]</span>
    <span class="n">pattern_rhs_splitter</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pattern_nonempty</span><span class="p">))</span>
    <span class="n">re_rhs_splitter</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern_rhs_splitter</span><span class="p">)</span>

    <span class="c1"># 2.c) Parsing</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_list_lhs_rhs</span><span class="p">):</span>
        <span class="c1"># Get next left-hand side (lhs) and multiple right-hand sides (rhs) belonging to it</span>
        <span class="n">txt_lhs</span> <span class="o">=</span> <span class="n">txt_list_lhs_rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">txt_rhs</span> <span class="o">=</span> <span class="n">txt_list_lhs_rhs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s2">&quot;Production list </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">heading</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">heading</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="c1"># Parse lhs: Get the single nonterminal</span>
        <span class="n">sym_lhs_nt</span> <span class="o">=</span> <span class="n">process_a_nonterminal</span><span class="p">(</span><span class="n">txt_lhs</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_add_nonterminal_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym_lhs_nt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start_symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grammar</span><span class="o">.</span><span class="n">start_symbol</span> <span class="o">=</span> <span class="n">sym_lhs_nt</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Left-hand side&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Text: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">txt_lhs</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Interpretation: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Right-hand sides:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Text: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">txt_rhs</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Interpretation:&quot;</span><span class="p">)</span>

        <span class="c1"># Parse rhs: Get several productions, each consisting of arbitrary symbols</span>
        <span class="n">sym_list_rhs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sym_or_seq</span> <span class="ow">in</span> <span class="n">re_rhs_splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">txt_rhs</span><span class="p">):</span>
            <span class="c1"># Mode 1: Nonterminals and terminals are enclosed by indicator symbols</span>
            <span class="k">if</span> <span class="n">re_nt</span> <span class="ow">and</span> <span class="n">re_t</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">text_is_a_nonterminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">):</span>
                    <span class="n">sym_nt</span> <span class="o">=</span> <span class="n">process_a_nonterminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">)</span>
                    <span class="n">sym_list_rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_nt</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">text_is_a_terminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">):</span>
                    <span class="n">sym_t</span> <span class="o">=</span> <span class="n">process_a_terminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">)</span>
                    <span class="n">sym_list_rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_t</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">txt_list_rhs</span> <span class="o">=</span> <span class="n">sym_or_seq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rule_separator_symbol</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_list_rhs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Add a rule</span>
                        <span class="n">_add_rule_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">sym_list_rhs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
                        <span class="n">sym_list_rhs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Mode 2: Only nonterminals are enclosed by indicator symbols</span>
            <span class="k">elif</span> <span class="n">re_nt</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">text_is_a_nonterminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">):</span>
                    <span class="n">sym_nt</span> <span class="o">=</span> <span class="n">process_a_nonterminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">)</span>
                    <span class="n">sym_list_rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_nt</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">txt_list_rhs</span> <span class="o">=</span> <span class="n">sym_or_seq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rule_separator_symbol</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">txt_rhs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">txt_list_rhs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Add a rule</span>
                            <span class="n">_add_rule_to_grammar</span><span class="p">(</span>
                                <span class="n">grammar</span><span class="p">,</span> <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">sym_list_rhs</span><span class="p">,</span> <span class="n">verbose</span>
                            <span class="p">)</span>
                            <span class="n">sym_list_rhs</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">txt_t</span> <span class="ow">in</span> <span class="n">txt_rhs</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                            <span class="n">sym_t</span> <span class="o">=</span> <span class="n">process_a_terminal</span><span class="p">(</span><span class="n">txt_t</span><span class="p">)</span>
                            <span class="n">sym_list_rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_t</span><span class="p">)</span>
            <span class="c1"># Mode 3: Only terminals are enclosed by indicator symbols</span>
            <span class="k">elif</span> <span class="n">re_t</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">text_is_a_terminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">):</span>
                    <span class="n">sym_t</span> <span class="o">=</span> <span class="n">process_a_terminal</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">)</span>
                    <span class="n">sym_list_rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_t</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">txt_list_rhs</span> <span class="o">=</span> <span class="n">sym_or_seq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rule_separator_symbol</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">txt_rhs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">txt_list_rhs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Add a rule</span>
                            <span class="n">_add_rule_to_grammar</span><span class="p">(</span>
                                <span class="n">grammar</span><span class="p">,</span> <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">sym_list_rhs</span><span class="p">,</span> <span class="n">verbose</span>
                            <span class="p">)</span>
                            <span class="n">sym_list_rhs</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">txt_nt</span> <span class="ow">in</span> <span class="n">txt_rhs</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                            <span class="n">sym_nt</span> <span class="o">=</span> <span class="n">process_a_nonterminal</span><span class="p">(</span><span class="n">txt_nt</span><span class="p">)</span>
                            <span class="n">sym_list_rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_nt</span><span class="p">)</span>
        <span class="c1"># Add the last rule</span>
        <span class="n">_add_rule_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">sym_list_rhs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># Check if the resulting grammar is valid</span>
    <span class="n">_check_grammar_validity</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_ebnf"><a class="viewcode-back" href="../../../../autoapi/alogos/_grammar/parsing/io_with_regex/index.html#alogos._grammar.parsing.read_ebnf">[docs]</a><span class="k">def</span> <span class="nf">read_ebnf</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">ebnf_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read grammar from text in EBNF notation.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    - https://en.wikipedia.org/wiki/Wirth_syntax_notation</span>
<span class="sd">    - http://homepage.divms.uiowa.edu/~jones/compiler/gtools/</span>

<span class="sd">    - Conversion of EBNF to BNF notation</span>

<span class="sd">        - https://stackoverflow.com/questions/2466484/converting-ebnf-to-bnf</span>
<span class="sd">        - https://stackoverflow.com/questions/2842809/lexers-vs-parsers</span>
<span class="sd">          useful notes in &quot;EBNF really doesn&#39;t add much to the power of grammars.&quot;</span>
<span class="sd">        - https://condor.depaul.edu/ichu/csc447/notes/wk3/BNF.pdf</span>
<span class="sd">          useful notes in summary on last page</span>
<span class="sd">        - https://stackoverflow.com/questions/20175248/ebnf-is-this-an-ll1-grammar</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Argument processing</span>
    <span class="n">ebnf_text</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;ebnf_text&quot;</span><span class="p">,</span> <span class="n">ebnf_text</span><span class="p">)</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">bool_arg</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">def_symbol</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="p">,</span>
        <span class="n">start_nt</span><span class="p">,</span>
        <span class="n">end_nt</span><span class="p">,</span>
        <span class="n">start_t1</span><span class="p">,</span>
        <span class="n">end_t1</span><span class="p">,</span>
        <span class="n">start_t2</span><span class="p">,</span>
        <span class="n">end_t2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_check_symbols_validity</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>

    <span class="c1"># Fixed symbols</span>
    <span class="n">start_group_symbol</span> <span class="o">=</span> <span class="s2">&quot;(&quot;</span>
    <span class="n">end_group_symbol</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>
    <span class="n">start_option_symbol</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span>
    <span class="n">end_option_symbol</span> <span class="o">=</span> <span class="s2">&quot;]&quot;</span>
    <span class="n">start_repeat_symbol</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span>
    <span class="n">end_repeat_symbol</span> <span class="o">=</span> <span class="s2">&quot;}&quot;</span>
    <span class="n">quantifier_0_to_1_symbol</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span>
    <span class="n">quantifier_1_to_n_symbol</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
    <span class="n">quantifier_0_to_n_symbol</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

    <span class="c1"># Conversion of symbols into escaped strings for secure use in regex patterns</span>
    <span class="n">esc_defining_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">def_symbol</span><span class="p">)</span>
    <span class="n">esc_rule_separator_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">rule_separator_symbol</span><span class="p">)</span>
    <span class="n">esc_start_nt</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_nt</span><span class="p">)</span>
    <span class="n">esc_end_nt</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_nt</span><span class="p">)</span>
    <span class="n">esc_start_t1</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_t1</span><span class="p">)</span>
    <span class="n">esc_end_t1</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_t1</span><span class="p">)</span>
    <span class="n">esc_start_t2</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_t2</span><span class="p">)</span>
    <span class="n">esc_end_t2</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_t2</span><span class="p">)</span>

    <span class="n">esc_start_group_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_group_symbol</span><span class="p">)</span>
    <span class="n">esc_end_group_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_group_symbol</span><span class="p">)</span>
    <span class="n">esc_start_option_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_option_symbol</span><span class="p">)</span>
    <span class="n">esc_end_option_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_option_symbol</span><span class="p">)</span>
    <span class="n">esc_start_repeat_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">start_repeat_symbol</span><span class="p">)</span>
    <span class="n">esc_end_repeat_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">end_repeat_symbol</span><span class="p">)</span>
    <span class="n">esc_quantifier_0_to_1_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">quantifier_0_to_1_symbol</span><span class="p">)</span>
    <span class="n">esc_quantifier_1_to_n_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">quantifier_1_to_n_symbol</span><span class="p">)</span>
    <span class="n">esc_quantifier_0_to_n_symbol</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">quantifier_0_to_n_symbol</span><span class="p">)</span>

    <span class="c1"># Print arguments and fixed symbols</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">represent</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Empty string&quot;</span> <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">text</span>

        <span class="n">heading</span> <span class="o">=</span> <span class="s2">&quot;Used symbols&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">heading</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">heading</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;defining_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">def_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rule_separator_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">rule_separator_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_nonterminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_nt</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_nonterminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_nt</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_terminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_t1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_terminal_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_t1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_terminal_symbol2:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_t2</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_terminal_symbol2:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_t2</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_group_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_group_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_group_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_group_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_option_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_option_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_option_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_option_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start_repeat_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">start_repeat_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end_repeat_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">end_repeat_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;quantifier_0_to_1_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">quantifier_0_to_1_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;quantifier_1_to_n_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">quantifier_1_to_n_symbol</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;quantifier_0_to_n_symbol:&quot;</span><span class="p">,</span> <span class="n">represent</span><span class="p">(</span><span class="n">quantifier_0_to_n_symbol</span><span class="p">))</span>

    <span class="c1"># Parsing step 1: Split full text into list of lhs (=nonterminal) and rhs (=other symbols)</span>
    <span class="c1"># 1.a) Regex pattern preparation</span>
    <span class="k">if</span> <span class="n">start_nt</span> <span class="ow">and</span> <span class="n">end_nt</span><span class="p">:</span>
        <span class="n">pattern_nt</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">esc_start_nt</span><span class="p">,</span> <span class="n">_ENCLOSED_NONTERMINAL_PATTERN</span><span class="p">,</span> <span class="n">esc_end_nt</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pattern_nt</span> <span class="o">=</span> <span class="n">_STANDALONE_NONTERMINAL_PATTERN</span>
    <span class="n">pattern_lhs_rhs</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{newline}{ws}</span><span class="s2">(</span><span class="si">{nonterminal}</span><span class="s2">)</span><span class="si">{ws}{defsymbol}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">newline</span><span class="o">=</span><span class="n">_NEWLINE</span><span class="p">,</span>
        <span class="n">ws</span><span class="o">=</span><span class="n">_MAX_OPT_WHITESPACE</span><span class="p">,</span>
        <span class="n">nonterminal</span><span class="o">=</span><span class="n">pattern_nt</span><span class="p">,</span>
        <span class="n">defsymbol</span><span class="o">=</span><span class="n">esc_defining_symbol</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">re_lhs_rhs</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern_lhs_rhs</span><span class="p">)</span>
    <span class="n">ebnf_text</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_NEWLINE</span> <span class="o">+</span> <span class="n">ebnf_text</span>
    <span class="p">)</span>  <span class="c1"># newline to guarantee recognition of the first lhs</span>

    <span class="c1"># 1.b) Parsing</span>
    <span class="n">txt_list_lhs_rhs</span> <span class="o">=</span> <span class="n">re_lhs_rhs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ebnf_text</span><span class="p">)</span>
    <span class="n">txt_list_lhs_rhs</span> <span class="o">=</span> <span class="n">txt_list_lhs_rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># get rid of an empty first match</span>

    <span class="c1"># Parsing step 2: Finding the single nonterminal symbol in lhs and arbitrary symbols in rhs</span>
    <span class="c1"># 2.a) Helper functions</span>
    <span class="k">def</span> <span class="nf">crop_symbol</span><span class="p">(</span><span class="n">txt_sym</span><span class="p">,</span> <span class="n">txt_start</span><span class="p">,</span> <span class="n">txt_end</span><span class="p">):</span>
        <span class="n">idx_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_start</span><span class="p">)</span>
        <span class="n">idx_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_sym</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">txt_sym</span><span class="p">[</span><span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">process_a_nonterminal</span><span class="p">(</span><span class="n">txt_nt</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
            <span class="n">txt_nt</span> <span class="o">=</span> <span class="n">crop_symbol</span><span class="p">(</span><span class="n">txt_nt</span><span class="p">,</span> <span class="n">start_nt</span><span class="p">,</span> <span class="n">end_nt</span><span class="p">)</span>
        <span class="n">sym_nt</span> <span class="o">=</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">NonterminalSymbol</span><span class="p">(</span><span class="n">txt_nt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sym_nt</span>

    <span class="k">def</span> <span class="nf">process_a_terminal</span><span class="p">(</span><span class="n">txt_t_enclosed</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">txt_t_enclosed</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">start_t1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">txt_t_enclosed</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">end_t1</span><span class="p">):</span>
            <span class="n">txt_t</span> <span class="o">=</span> <span class="n">crop_symbol</span><span class="p">(</span><span class="n">txt_t_enclosed</span><span class="p">,</span> <span class="n">start_t1</span><span class="p">,</span> <span class="n">end_t1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt_t</span> <span class="o">=</span> <span class="n">crop_symbol</span><span class="p">(</span><span class="n">txt_t_enclosed</span><span class="p">,</span> <span class="n">start_t2</span><span class="p">,</span> <span class="n">end_t2</span><span class="p">)</span>
        <span class="n">sym_t</span> <span class="o">=</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">TerminalSymbol</span><span class="p">(</span><span class="n">txt_t</span><span class="p">)</span>
        <span class="c1"># _add_terminal_to_grammar(grammar, sym_t)  # deferred to process_a_rule for empty string</span>
        <span class="k">return</span> <span class="n">sym_t</span>

    <span class="k">def</span> <span class="nf">text_is_a_nonterminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re_nt</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">text_is_a_terminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re_t</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_a_nt_special_mix</span><span class="p">(</span><span class="n">rhs_text</span><span class="p">):</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">process_a_nonterminal</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">text_is_a_nonterminal</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">text</span>
            <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">re_rhs_splitter</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">rhs_text</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">seq</span>

    <span class="k">def</span> <span class="nf">find_an_innermost_bracket_pair</span><span class="p">(</span><span class="n">txt_list</span><span class="p">):</span>
        <span class="n">found_bracket</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">last_opening_symbol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">last_opening_symbol_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">txt_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">text</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">start_group_symbol</span><span class="p">,</span>
                    <span class="n">start_option_symbol</span><span class="p">,</span>
                    <span class="n">start_repeat_symbol</span><span class="p">,</span>
                <span class="p">]:</span>
                    <span class="n">last_opening_symbol</span> <span class="o">=</span> <span class="n">text</span>
                    <span class="n">last_opening_symbol_idx</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">text</span> <span class="o">==</span> <span class="n">end_group_symbol</span>
                    <span class="ow">and</span> <span class="n">last_opening_symbol</span> <span class="o">==</span> <span class="n">start_group_symbol</span>
                <span class="p">):</span>
                    <span class="n">found_bracket</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">last_opening_symbol_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">text</span> <span class="o">==</span> <span class="n">end_option_symbol</span>
                    <span class="ow">and</span> <span class="n">last_opening_symbol</span> <span class="o">==</span> <span class="n">start_option_symbol</span>
                <span class="p">):</span>
                    <span class="n">found_bracket</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;option&quot;</span><span class="p">,</span> <span class="n">last_opening_symbol_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">text</span> <span class="o">==</span> <span class="n">end_repeat_symbol</span>
                    <span class="ow">and</span> <span class="n">last_opening_symbol</span> <span class="o">==</span> <span class="n">start_repeat_symbol</span>
                <span class="p">):</span>
                    <span class="n">found_bracket</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="n">last_opening_symbol_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">found_bracket</span>

    <span class="k">def</span> <span class="nf">find_a_quantifier</span><span class="p">(</span><span class="n">txt_list</span><span class="p">):</span>
        <span class="n">found_quantifier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">txt_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># a quantifier on zeroth position is ignored</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">quantifier_0_to_1_symbol</span><span class="p">:</span>
                    <span class="n">found_quantifier</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;0 to 1&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">quantifier_1_to_n_symbol</span><span class="p">:</span>
                    <span class="n">found_quantifier</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;1 to n&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">quantifier_0_to_n_symbol</span><span class="p">:</span>
                    <span class="n">found_quantifier</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;0 to n&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">found_quantifier</span>

    <span class="k">def</span> <span class="nf">create_nt_with_derived_name</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">new_text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{text}{suffix}{count}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">text</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">cnt</span>
            <span class="p">)</span>
            <span class="n">sym_nt</span> <span class="o">=</span> <span class="n">process_a_nonterminal</span><span class="p">(</span><span class="n">new_text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sym_nt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_nonterminals</span><span class="p">:</span>
                <span class="n">seen_nonterminals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym_nt</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">sym_nt</span>

    <span class="k">def</span> <span class="nf">cut_out_exclusive</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[:</span><span class="n">start_idx</span><span class="p">]</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">start_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">end_idx</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">end_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">cut_out_left_inclusive</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[:</span><span class="n">start_idx</span><span class="p">]</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">end_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">remove_brackets</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove {}, () and [] from a EBNF right-hand side by creating new helper rules.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://stackoverflow.com/questions/2466484/converting-ebnf-to-bnf</span>
<span class="sd">          Caution: {} is imprecise because {a|b|c} means (a|b|c)* and not a*|b|c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">sym_list_rhs</span> <span class="o">=</span> <span class="n">rule</span>
        <span class="n">helper_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Find the first pair of brackets that have no other brackets within them</span>
            <span class="n">bracket_hit</span> <span class="o">=</span> <span class="n">find_an_innermost_bracket_pair</span><span class="p">(</span><span class="n">sym_list_rhs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bracket_hit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">bracket_type</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">=</span> <span class="n">bracket_hit</span>

            <span class="c1"># Handle {} by reducing the expression {something} to the expression (something)*</span>
            <span class="k">if</span> <span class="n">bracket_type</span> <span class="o">==</span> <span class="s2">&quot;repeat&quot;</span><span class="p">:</span>
                <span class="n">sym_list_rhs</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;(&quot;</span>
                <span class="n">sym_list_rhs</span><span class="p">[</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>
                <span class="n">end_idx_incr</span> <span class="o">=</span> <span class="n">end_idx</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">sym_list_rhs</span><span class="p">[</span><span class="n">end_idx_incr</span><span class="p">:</span><span class="n">end_idx_incr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="c1"># Handle the other two types of brackets</span>
            <span class="n">sym_nt_new</span> <span class="o">=</span> <span class="n">create_nt_with_derived_name</span><span class="p">(</span>
                <span class="n">sym_lhs_nt</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">_SHARED_SUFFIX</span>
            <span class="p">)</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">sym_list_inner</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cut_out_exclusive</span><span class="p">(</span>
                <span class="n">sym_list_rhs</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span>
            <span class="p">)</span>
            <span class="n">sym_list_rhs</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">sym_nt_new</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>
            <span class="k">if</span> <span class="n">bracket_type</span> <span class="o">==</span> <span class="s2">&quot;group&quot;</span><span class="p">:</span>
                <span class="c1"># Handle ()</span>
                <span class="n">helper_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_nt_new</span><span class="p">,</span> <span class="n">sym_list_inner</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">bracket_type</span> <span class="o">==</span> <span class="s2">&quot;option&quot;</span><span class="p">:</span>
                <span class="c1"># Handle []</span>
                <span class="n">empty</span> <span class="o">=</span> <span class="n">process_a_terminal</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">helper_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_nt_new</span><span class="p">,</span> <span class="n">sym_list_inner</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;|&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">empty</span><span class="p">])</span>

            <span class="n">helper_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">helper_rule</span><span class="p">)</span>
        <span class="n">modified_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">sym_list_rhs</span><span class="p">)</span>
        <span class="n">new_rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">modified_rule</span><span class="p">]</span> <span class="o">+</span> <span class="n">helper_rules</span>
        <span class="k">return</span> <span class="n">new_rules</span>

    <span class="k">def</span> <span class="nf">remove_quantifiers</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove *, + and ? from a EBNF right-hand side by creating new helper rules.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://stackoverflow.com/questions/2466484/converting-ebnf-to-bnf</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">list_rhs</span> <span class="o">=</span> <span class="n">rule</span>
        <span class="n">helper_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Find the first quantifier</span>
            <span class="n">quantifier_hit</span> <span class="o">=</span> <span class="n">find_a_quantifier</span><span class="p">(</span><span class="n">list_rhs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">quantifier_hit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">quantifier_type</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">quantifier_hit</span>

            <span class="c1"># Handle all three types of quantifiers</span>
            <span class="n">sym_nt_new</span> <span class="o">=</span> <span class="n">create_nt_with_derived_name</span><span class="p">(</span>
                <span class="n">sym_lhs_nt</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">_SHARED_SUFFIX</span>
            <span class="p">)</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cut_out_left_inclusive</span><span class="p">(</span><span class="n">list_rhs</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="n">list_rhs</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">sym_nt_new</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>
            <span class="k">if</span> <span class="n">quantifier_type</span> <span class="o">==</span> <span class="s2">&quot;0 to 1&quot;</span><span class="p">:</span>
                <span class="n">sym_t_empty</span> <span class="o">=</span> <span class="n">process_a_terminal</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">helper_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_nt_new</span><span class="p">,</span> <span class="n">inner</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;|&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">sym_t_empty</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">quantifier_type</span> <span class="o">==</span> <span class="s2">&quot;0 to n&quot;</span><span class="p">:</span>
                <span class="n">sym_t_empty</span> <span class="o">=</span> <span class="n">process_a_terminal</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">helper_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_nt_new</span><span class="p">,</span> <span class="p">[</span><span class="n">sym_nt_new</span><span class="p">]</span> <span class="o">+</span> <span class="n">inner</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;|&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">sym_t_empty</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">quantifier_type</span> <span class="o">==</span> <span class="s2">&quot;1 to n&quot;</span><span class="p">:</span>
                <span class="n">helper_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_nt_new</span><span class="p">,</span> <span class="n">inner</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;|&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">sym_nt_new</span><span class="p">]</span> <span class="o">+</span> <span class="n">inner</span><span class="p">)</span>
            <span class="n">helper_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">helper_rule</span><span class="p">)</span>
        <span class="n">modified_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">list_rhs</span><span class="p">)</span>
        <span class="n">new_rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">modified_rule</span><span class="p">]</span> <span class="o">+</span> <span class="n">helper_rules</span>
        <span class="k">return</span> <span class="n">new_rules</span>

    <span class="k">def</span> <span class="nf">remove_alternation_and_nonsense</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
        <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">list_rhs</span> <span class="o">=</span> <span class="n">rule</span>
        <span class="n">part</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">splitted_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_rhs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">rule_separator_symbol</span><span class="p">:</span>
                    <span class="n">rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
                    <span class="n">splitted_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
        <span class="n">splitted_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">splitted_rules</span>

    <span class="k">def</span> <span class="nf">process_a_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
        <span class="c1"># Treat all occurrences of brackets: {}, () and []</span>
        <span class="n">intermediary_rules1</span> <span class="o">=</span> <span class="n">remove_brackets</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>

        <span class="c1"># Treat all occurrences of quantifiers: *, + and ?</span>
        <span class="n">intermediary_rules2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">intermediary_rule</span> <span class="ow">in</span> <span class="n">intermediary_rules1</span><span class="p">:</span>
            <span class="n">new_rules</span> <span class="o">=</span> <span class="n">remove_quantifiers</span><span class="p">(</span><span class="n">intermediary_rule</span><span class="p">)</span>
            <span class="n">intermediary_rules2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_rules</span><span class="p">)</span>

        <span class="c1"># Treat all occurrences of alternation symbols: |</span>
        <span class="n">final_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">intermediary_rule</span> <span class="ow">in</span> <span class="n">intermediary_rules2</span><span class="p">:</span>
            <span class="n">new_rules</span> <span class="o">=</span> <span class="n">remove_alternation_and_nonsense</span><span class="p">(</span><span class="n">intermediary_rule</span><span class="p">)</span>
            <span class="n">final_rules</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_rules</span><span class="p">)</span>

        <span class="c1"># Add all final rules to the grammar</span>
        <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">final_rules</span><span class="p">:</span>
            <span class="c1"># Add nonterminals to grammar</span>
            <span class="n">_add_nonterminal_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">lhs</span><span class="p">)</span>
            <span class="c1"># Add terminals to grammar here, so that all empty strings arrive at correct position</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">rhs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">TerminalSymbol</span><span class="p">):</span>
                    <span class="n">_add_terminal_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
            <span class="c1"># Add rule</span>
            <span class="n">_add_rule_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># 2.b) Regex pattern preparation</span>
    <span class="c1"># Nonterminal symbols</span>
    <span class="n">re_nt</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern_nt</span><span class="p">)</span>
    <span class="c1"># Terminal symbols</span>
    <span class="n">use_t1</span> <span class="o">=</span> <span class="n">start_t1</span> <span class="ow">and</span> <span class="n">end_t1</span>
    <span class="n">use_t2</span> <span class="o">=</span> <span class="n">start_t2</span> <span class="ow">and</span> <span class="n">end_t2</span>
    <span class="n">pattern_t1</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">esc_start_t1</span><span class="p">,</span> <span class="n">_ENCLOSED_TERMINAL_PATTERN</span><span class="p">,</span> <span class="n">esc_end_t1</span><span class="p">)</span>
    <span class="n">pattern_t2</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">esc_start_t2</span><span class="p">,</span> <span class="n">_ENCLOSED_TERMINAL_PATTERN</span><span class="p">,</span> <span class="n">esc_end_t2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_t1</span> <span class="ow">and</span> <span class="n">use_t2</span><span class="p">:</span>
        <span class="n">re_t</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">|</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern_t1</span><span class="p">,</span> <span class="n">pattern_t2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">use_t1</span><span class="p">:</span>
        <span class="n">re_t</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern_t1</span><span class="p">))</span>
    <span class="c1"># Special symbols</span>
    <span class="n">special_symbols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">esc_rule_separator_symbol</span><span class="p">,</span>
        <span class="n">esc_start_group_symbol</span><span class="p">,</span>
        <span class="n">esc_end_group_symbol</span><span class="p">,</span>
        <span class="n">esc_start_option_symbol</span><span class="p">,</span>
        <span class="n">esc_end_option_symbol</span><span class="p">,</span>
        <span class="n">esc_start_repeat_symbol</span><span class="p">,</span>
        <span class="n">esc_end_repeat_symbol</span><span class="p">,</span>
        <span class="n">esc_quantifier_0_to_1_symbol</span><span class="p">,</span>
        <span class="n">esc_quantifier_1_to_n_symbol</span><span class="p">,</span>
        <span class="n">esc_quantifier_0_to_n_symbol</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">pattern_special_symbols</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">special_symbols</span><span class="p">))</span>
    <span class="c1"># Right-hand sides</span>
    <span class="n">pattern_rhs_splitter</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">|</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern_special_symbols</span><span class="p">,</span> <span class="n">pattern_nt</span><span class="p">)</span>
    <span class="n">re_rhs_splitter</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern_rhs_splitter</span><span class="p">)</span>

    <span class="c1"># 2.c) Parsing</span>
    <span class="n">seen_nonterminals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">txt_list_lhs_rhs</span><span class="p">):</span>
        <span class="c1"># Get next left-hand side (lhs) and multiple right-hand sides (rhs) belonging to it</span>
        <span class="n">txt_lhs</span> <span class="o">=</span> <span class="n">txt_list_lhs_rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">txt_rhs</span> <span class="o">=</span> <span class="n">txt_list_lhs_rhs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="s2">&quot;Production list </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">heading</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">heading</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="c1"># Parse lhs: Get the single nonterminal</span>
        <span class="n">sym_lhs_nt</span> <span class="o">=</span> <span class="n">process_a_nonterminal</span><span class="p">(</span><span class="n">txt_lhs</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start_symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grammar</span><span class="o">.</span><span class="n">start_symbol</span> <span class="o">=</span> <span class="n">sym_lhs_nt</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Left-hand side&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Text: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">txt_lhs</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Interpretation: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Right-hand sides:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Text: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">txt_rhs</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Interpretation:&quot;</span><span class="p">)</span>

        <span class="c1"># Parse rhs: Get several productions, each consisting of arbitrary symbols</span>
        <span class="n">t_vs_others_seq</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">process_a_terminal</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="n">text_is_a_terminal</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">else</span> <span class="n">text</span>
            <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">re_t</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">txt_rhs</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">t_nt_vs_special_sym_seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sym_or_seq</span> <span class="ow">in</span> <span class="n">t_vs_others_seq</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">,</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">TerminalSymbol</span><span class="p">):</span>
                <span class="n">t_nt_vs_special_sym_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sym_list</span> <span class="o">=</span> <span class="n">process_a_nt_special_mix</span><span class="p">(</span><span class="n">sym_or_seq</span><span class="p">)</span>
                <span class="n">t_nt_vs_special_sym_seq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sym_list</span><span class="p">)</span>

        <span class="c1"># Process the rule consisting of lhs and rhs</span>
        <span class="c1"># = remove brackets, quantifiers, alternation and add the rule to the grammar</span>
        <span class="n">rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">t_nt_vs_special_sym_seq</span><span class="p">)</span>
        <span class="n">process_a_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>

    <span class="c1"># Delete duplicate rules that come from processing brackets and quantifiers</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_delete_duplicate_rules</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">only_helper_rules</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># If may fail for some grammars, where the subsequent validity check reports in detail</span>
        <span class="k">pass</span>

    <span class="c1"># Check if the resulting grammar is valid</span>
    <span class="n">_check_grammar_validity</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span></div>


<span class="c1"># Writing BNF and EBNF</span>


<div class="viewcode-block" id="write_bnf"><a class="viewcode-back" href="../../../../autoapi/alogos/_grammar/parsing/io_with_regex/index.html#alogos._grammar.parsing.write_bnf">[docs]</a><span class="k">def</span> <span class="nf">write_bnf</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">rules_on_separate_lines</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write grammar as text in BNF notation.&quot;&quot;&quot;</span>
    <span class="c1"># Argument processing</span>
    <span class="n">rules_on_separate_lines</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">bool_arg</span><span class="p">(</span>
        <span class="s2">&quot;rules_on_separate_lines&quot;</span><span class="p">,</span> <span class="n">rules_on_separate_lines</span>
    <span class="p">)</span>
    <span class="p">(</span>
        <span class="n">def_symbol</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="p">,</span>
        <span class="n">start_nt</span><span class="p">,</span>
        <span class="n">end_nt</span><span class="p">,</span>
        <span class="n">start_t1</span><span class="p">,</span>
        <span class="n">end_t1</span><span class="p">,</span>
        <span class="n">start_t2</span><span class="p">,</span>
        <span class="n">end_t2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_check_symbols_validity</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
    <span class="n">use_nt</span> <span class="o">=</span> <span class="n">start_nt</span> <span class="ow">and</span> <span class="n">end_nt</span>
    <span class="n">use_t1</span> <span class="o">=</span> <span class="n">start_t1</span> <span class="ow">and</span> <span class="n">end_t1</span>
    <span class="n">use_t2</span> <span class="o">=</span> <span class="n">start_t2</span> <span class="ow">and</span> <span class="n">end_t2</span>

    <span class="c1"># Regex pattern preparation</span>
    <span class="n">re_nt_standalone</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">_STANDALONE_NONTERMINAL_PATTERN</span><span class="p">)</span>
    <span class="n">re_t_standalone</span> <span class="o">=</span> <span class="n">_re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">_STANDALONE_TERMINAL_PATTERN</span><span class="p">)</span>

    <span class="c1"># Helper functions</span>
    <span class="k">def</span> <span class="nf">contains_nt_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">start_nt</span> <span class="ow">in</span> <span class="n">text</span> <span class="ow">or</span> <span class="n">end_nt</span> <span class="ow">in</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">contains_t1_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">start_t1</span> <span class="ow">in</span> <span class="n">text</span> <span class="ow">or</span> <span class="n">end_t1</span> <span class="ow">in</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">contains_t2_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">start_t2</span> <span class="ow">in</span> <span class="n">text</span> <span class="ow">or</span> <span class="n">end_t2</span> <span class="ow">in</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">invalid_unenclosed_nonterminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">re_nt_standalone</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invalid_unenclosed_terminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">re_t_standalone</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_nonterminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">use_nt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">contains_nt_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_write_nonterminal_error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start_nt</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end_nt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">invalid_unenclosed_nonterminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_write_nonterminal_error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">text_with_start_and_end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text_with_start_and_end</span>

    <span class="k">def</span> <span class="nf">process_terminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">use_t1</span> <span class="ow">and</span> <span class="n">use_t2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">contains_t1_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="ow">and</span> <span class="n">contains_t2_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_write_terminal_error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">contains_t1_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">start_t2</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">end_t2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">start_t1</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">end_t1</span>
        <span class="k">elif</span> <span class="n">use_t1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">contains_t1_indicator</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_write_terminal_error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start_t1</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end_t1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">invalid_unenclosed_terminal</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_write_terminal_error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">text_with_start_and_end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text_with_start_and_end</span>

    <span class="c1"># Write text</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">list_rhs</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Left-hand side nonterminal symbol</span>
        <span class="n">txt_lhs_nt</span> <span class="o">=</span> <span class="n">process_nonterminal</span><span class="p">(</span><span class="n">sym_lhs_nt</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="n">txt_lhs_nt_def</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">txt_lhs_nt</span><span class="p">,</span> <span class="n">def_symbol</span><span class="p">)</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">txt_lhs_nt_def</span><span class="p">)</span>
        <span class="c1"># Right-hand side sequence of symbols</span>
        <span class="k">for</span> <span class="n">sym_list_rhs</span> <span class="ow">in</span> <span class="n">list_rhs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">sym_list_rhs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">NonterminalSymbol</span><span class="p">):</span>
                    <span class="n">txt_nt</span> <span class="o">=</span> <span class="n">process_nonterminal</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                    <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">txt_nt</span><span class="p">)</span>
                    <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">txt_t</span> <span class="o">=</span> <span class="n">process_terminal</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                    <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">txt_t</span><span class="p">)</span>
                    <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rules_on_separate_lines</span><span class="p">:</span>
                <span class="n">indentation</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">txt_lhs_nt</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">def_symbol</span><span class="p">))</span>
                <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_NEWLINE</span><span class="p">)</span>
                <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indentation</span><span class="p">)</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rule_separator_symbol</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rules_on_separate_lines</span><span class="p">:</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># remove last lhs indent</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># remove last newline</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># remove last rule_separator_symbol</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># remove last whitespace</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_NEWLINE</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span></div>


<div class="viewcode-block" id="write_ebnf"><a class="viewcode-back" href="../../../../autoapi/alogos/_grammar/parsing/io_with_regex/index.html#alogos._grammar.parsing.write_ebnf">[docs]</a><span class="k">def</span> <span class="nf">write_ebnf</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">rules_on_separate_lines</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write grammar as text in EBNF notation.&quot;&quot;&quot;</span>
    <span class="c1"># Currently reduced to BNF, i.e. no simplifications yet that are possible with EBNF constructs</span>
    <span class="k">return</span> <span class="n">write_bnf</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">rules_on_separate_lines</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span></div>


<span class="c1"># Helper functions</span>


<span class="k">def</span> <span class="nf">_check_symbols_validity</span><span class="p">(</span>
    <span class="n">defining_symbol</span><span class="p">,</span>
    <span class="n">rule_separator_symbol</span><span class="p">,</span>
    <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
    <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
    <span class="n">start_terminal_symbol</span><span class="p">,</span>
    <span class="n">end_terminal_symbol</span><span class="p">,</span>
    <span class="n">start_terminal_symbol2</span><span class="p">,</span>
    <span class="n">end_terminal_symbol2</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># Type checking</span>
    <span class="n">def_symbol</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;defining_symbol&quot;</span><span class="p">,</span> <span class="n">defining_symbol</span><span class="p">)</span>
    <span class="n">rule_separator_symbol</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;rule_separator_symbol&quot;</span><span class="p">,</span> <span class="n">rule_separator_symbol</span><span class="p">)</span>
    <span class="n">start_nt</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;start_nonterminal_symbol&quot;</span><span class="p">,</span> <span class="n">start_nonterminal_symbol</span><span class="p">)</span>
    <span class="n">end_nt</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;end_nonterminal_symbol&quot;</span><span class="p">,</span> <span class="n">end_nonterminal_symbol</span><span class="p">)</span>
    <span class="n">start_t1</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;start_terminal_symbol&quot;</span><span class="p">,</span> <span class="n">start_terminal_symbol</span><span class="p">)</span>
    <span class="n">end_t1</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;end_terminal_symbol&quot;</span><span class="p">,</span> <span class="n">end_terminal_symbol</span><span class="p">)</span>
    <span class="n">start_t2</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;start_terminal_symbol2&quot;</span><span class="p">,</span> <span class="n">start_terminal_symbol2</span><span class="p">)</span>
    <span class="n">end_t2</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;end_terminal_symbol2&quot;</span><span class="p">,</span> <span class="n">end_terminal_symbol2</span><span class="p">)</span>

    <span class="c1"># Consistent: If one symbol is provided, the partner symbol needs to be provided too</span>
    <span class="k">if</span> <span class="n">_ap</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">start_nt</span><span class="p">,</span> <span class="n">end_nt</span><span class="p">):</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_delimiter_symbol_error_1</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_ap</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">start_t1</span><span class="p">,</span> <span class="n">end_t1</span><span class="p">):</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_surrounding_symbol_error_2</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_ap</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">start_t2</span><span class="p">,</span> <span class="n">end_t2</span><span class="p">):</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_surrounding_symbol_error_3</span><span class="p">()</span>

    <span class="c1"># Ordered: If terminal_symbols1 are not provided, but terminal_symbols2 are, assign 2 to 1</span>
    <span class="k">if</span> <span class="n">start_t1</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">start_t2</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">start_t1</span> <span class="o">=</span> <span class="n">start_t2</span>
        <span class="n">start_t2</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">end_t1</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">end_t2</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">end_t1</span> <span class="o">=</span> <span class="n">end_t2</span>
        <span class="n">end_t2</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># Sufficient: Either nonterminals, or terminals, or both need to be enclosed by delimiters</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">start_nt</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">start_t1</span><span class="p">:</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_surrounding_symbol_error_4</span><span class="p">()</span>

    <span class="c1"># Unique: Nonterminal and terminal indicator symbols need to be different</span>
    <span class="n">ind_nt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_nt</span><span class="p">,</span> <span class="n">end_nt</span><span class="p">])</span>
    <span class="n">ind_t</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_t1</span><span class="p">,</span> <span class="n">end_t1</span><span class="p">,</span> <span class="n">start_t2</span><span class="p">,</span> <span class="n">end_t2</span><span class="p">])</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="n">ind_nt</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ind_t</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;&quot;</span> <span class="ow">in</span> <span class="n">overlap</span><span class="p">:</span>
        <span class="n">overlap</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
        <span class="n">listing</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">overlap</span><span class="p">)</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_surrounding_symbol_error_5</span><span class="p">(</span><span class="n">listing</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">def_symbol</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="p">,</span>
        <span class="n">start_nt</span><span class="p">,</span>
        <span class="n">end_nt</span><span class="p">,</span>
        <span class="n">start_t1</span><span class="p">,</span>
        <span class="n">end_t1</span><span class="p">,</span>
        <span class="n">start_t2</span><span class="p">,</span>
        <span class="n">end_t2</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_grammar_validity</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check criteria that a context-free grammar needs to fulfill.</span>

<span class="sd">    Criteria that raise a GrammarError if not fulfilled:</span>
<span class="sd">    - The sets of nonterminals, terminals and productions need to be non-empty.</span>
<span class="sd">    - Every nonterminal needs a production rule where it appears on the left-hand side,</span>
<span class="sd">      otherwise it can not be rewritten.</span>
<span class="sd">    - Every nonterminal needs a production rule that is non-recursive</span>
<span class="sd">      (also considering co-recursion), otherwise when the symbol appears once</span>
<span class="sd">      in a derivation there is no way to reach an end.</span>

<span class="sd">    Criteria that only emit warnings if not fulfilled (because algorithms can work anyways):</span>
<span class="sd">    - The sets of nonterminals and terminals should be disjoint.</span>
<span class="sd">    - Every production rule should be be unique.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    - https://en.wikipedia.org/wiki/Context-free_grammar#Proper_CFGs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Raise an error if the grammar contains an empty set</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="p">:</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_empty_productions_error</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grammar</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">:</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_empty_nonterminals_error</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grammar</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">:</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_empty_terminals_error</span><span class="p">()</span>

    <span class="c1"># Emit a warning if nonterminals and terminals are not disjoint sets of symbols</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">)</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">intersection</span><span class="p">:</span>
        <span class="n">_warnings</span><span class="o">.</span><span class="n">_warn_symbol_set_overlap</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>

    <span class="c1"># Raise an error if a nonterminal (on rhs) has no corresponding production rule (on lhs)</span>
    <span class="n">lhs_nonterminals</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">rhs_nonterminals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">rhs_multiple</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_multiple</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">rhs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">NonterminalSymbol</span><span class="p">):</span>
                    <span class="n">rhs_nonterminals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_nonterminals</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs_nonterminals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">missing_nonterminals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">rhs_nonterminals</span> <span class="k">if</span> <span class="n">nt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs_nonterminals</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_nonterminals</span><span class="p">:</span>
            <span class="n">_exceptions</span><span class="o">.</span><span class="n">raise_missing_nonterminals_error</span><span class="p">(</span><span class="n">missing_nonterminals</span><span class="p">)</span>

    <span class="c1"># Emit a warning if some production rules are not unique</span>
    <span class="n">repeated_productions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_vals</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_vals</span><span class="p">:</span>
            <span class="n">rhs_text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">NonterminalSymbol</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">sym</span><span class="o">.</span><span class="n">text</span>
                <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">rhs</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">rhs_text</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;  &lt;</span><span class="si">{}</span><span class="s2">&gt; ::= </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">rhs_text</span><span class="p">)</span>
                <span class="n">repeated_productions</span><span class="p">[</span><span class="n">text</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rhs_text</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">repeated_productions</span><span class="p">:</span>
        <span class="n">_warnings</span><span class="o">.</span><span class="n">_warn_repeated_productions</span><span class="p">(</span><span class="n">repeated_productions</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_delete_duplicate_rules</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">only_helper_rules</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove duplicate rules, i.e. when different lhs share exactly the same rhs.&quot;&quot;&quot;</span>
    <span class="c1"># Delete lhs which have exactly the same rhs as another lhs</span>
    <span class="c1"># Example:</span>
    <span class="c1">#  S -&gt; A B</span>
    <span class="c1">#  A -&gt; 1 | 4</span>
    <span class="c1">#  B -&gt; 1 | 4 ... delete it and replace occurrences of B in the rhs of every other lhs</span>
    <span class="n">known_rhs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">delete_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">replacement_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Make sure the start symbol is considered first</span>
    <span class="n">lhs_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">lhs_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">)</span>
    <span class="n">lhs_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">grammar</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">]</span> <span class="o">+</span> <span class="n">lhs_list</span>
    <span class="n">rule_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="p">[</span><span class="n">lhs</span><span class="p">])</span> <span class="k">for</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="n">lhs_list</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rule_list</span><span class="p">:</span>
        <span class="c1"># Optionally skip rules where the lhs does not start with an underscore</span>
        <span class="k">if</span> <span class="n">only_helper_rules</span> <span class="ow">and</span> <span class="n">_SHARED_SUFFIX</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">lhs</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># All lhs (except start symbol) may be deleted if their rhs is the same as in another lhs</span>
        <span class="n">rhs_hashable</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs_hashable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">known_rhs</span><span class="p">:</span>
            <span class="n">known_rhs</span><span class="p">[</span><span class="n">rhs_hashable</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">known_lhs</span> <span class="o">=</span> <span class="n">known_rhs</span><span class="p">[</span><span class="n">rhs_hashable</span><span class="p">]</span>
            <span class="n">replacement_map</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">=</span> <span class="n">known_lhs</span>
            <span class="n">delete_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>

    <span class="c1"># Replace lhs symbols that will be deleted</span>
    <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_multiple</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">rhs_idx</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rhs_multiple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">symb_idx</span><span class="p">,</span> <span class="n">symb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rhs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">symb</span> <span class="ow">in</span> <span class="n">replacement_map</span><span class="p">:</span>
                    <span class="n">new_symb</span> <span class="o">=</span> <span class="n">replacement_map</span><span class="p">[</span><span class="n">symb</span><span class="p">]</span>
                    <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="p">[</span><span class="n">lhs</span><span class="p">][</span><span class="n">rhs_idx</span><span class="p">][</span><span class="n">symb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_symb</span>

    <span class="c1"># Delete lhs symbols and their productions</span>
    <span class="k">for</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="n">delete_list</span><span class="p">:</span>
        <span class="n">_remove_nonterminal_from_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">lhs</span><span class="p">)</span>
        <span class="n">_remove_rule_from_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">lhs</span><span class="p">)</span>


<span class="c1"># Helper functions, which have to change when other data structures are used for symbols or rules</span>


<span class="k">def</span> <span class="nf">_add_terminal_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
    <span class="n">grammar</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_add_nonterminal_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
    <span class="n">grammar</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_remove_nonterminal_from_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
    <span class="n">grammar</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_add_rule_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym_lhs_nt</span><span class="p">,</span> <span class="n">sym_list_rhs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="c1"># Special case: Empty rhs is interpreted as empty terminal symbol</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sym_list_rhs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sym_t_empty</span> <span class="o">=</span> <span class="n">_data_structures</span><span class="o">.</span><span class="n">TerminalSymbol</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">_add_terminal_to_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym_t_empty</span><span class="p">)</span>
        <span class="n">sym_list_rhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym_t_empty</span><span class="p">]</span>
    <span class="c1"># Print recognized rule</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    </span><span class="si">{}</span><span class="s2"> -&gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sym_lhs_nt</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">sym_list_rhs</span><span class="p">)))</span>
    <span class="c1"># Add rule</span>
    <span class="k">if</span> <span class="n">sym_lhs_nt</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="p">:</span>
        <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="p">[</span><span class="n">sym_lhs_nt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym_list_rhs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="p">[</span><span class="n">sym_lhs_nt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym_list_rhs</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_remove_rule_from_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">sym_lhs_nt</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">grammar</span><span class="o">.</span><span class="n">production_rules</span><span class="p">[</span><span class="n">sym_lhs_nt</span><span class="p">]</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Robert Haas.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>