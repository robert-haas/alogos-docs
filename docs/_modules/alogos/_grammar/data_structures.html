

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>alogos._grammar.data_structures &mdash; alogos 0.2.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/alogos.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/package_references.html">Package References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/quickstart.html">Quickstart Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/getting_started.html">Getting Started Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/examples.html">Code Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/index.html">API Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">alogos</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>alogos._grammar.data_structures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for alogos._grammar.data_structures</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Data structures for a grammar, derivation tree and their parts.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span> <span class="k">as</span> <span class="nn">_collections</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">_copy</span>
<span class="kn">import</span> <span class="nn">json</span> <span class="k">as</span> <span class="nn">_json</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">_random</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span> <span class="k">as</span> <span class="n">_chain</span>

<span class="kn">from</span> <span class="nn">ordered_set</span> <span class="kn">import</span> <span class="n">OrderedSet</span> <span class="k">as</span> <span class="n">_OrderedSet</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exceptions</span> <span class="k">as</span> <span class="n">_exceptions</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">warnings</span> <span class="k">as</span> <span class="n">_warnings</span>
<span class="kn">from</span> <span class="nn">.._utilities</span> <span class="kn">import</span> <span class="n">argument_processing</span> <span class="k">as</span> <span class="n">_ap</span>
<span class="kn">from</span> <span class="nn">.._utilities.operating_system</span> <span class="kn">import</span> <span class="n">NEWLINE</span> <span class="k">as</span> <span class="n">_NEWLINE</span>


<div class="viewcode-block" id="Grammar"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar">[docs]</a><span class="k">class</span> <span class="nc">Grammar</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Context-free grammar (CFG) for defining a formal language.</span>

<span class="sd">    The role of this class is explained by first introducing</span>
<span class="sd">    basic concepts from formal language theory and then</span>
<span class="sd">    describing the main tasks a grammar can be used for.</span>

<span class="sd">    1. Technical terms from formal language theory</span>

<span class="sd">        - A **grammar** is a mathematical device to define a formal</span>
<span class="sd">          language.</span>
<span class="sd">        - A **language** is a finite or infinite set of strings.</span>
<span class="sd">        - A **string** is a finite sequence of symbols that all belong</span>
<span class="sd">          to a single alphabet.</span>
<span class="sd">        - An **alphabet** is a finite set of symbols.</span>
<span class="sd">        - In mathematical terms, a grammar is usually defined as a</span>
<span class="sd">          tuple ``(N, T, P, S)`` where</span>

<span class="sd">            - ``N`` is a set of **nonterminal symbols**, also known</span>
<span class="sd">              as **variables**.</span>
<span class="sd">            - ``T`` is a set of **terminal symbols**, which has no</span>
<span class="sd">              overlap with ``N``.</span>
<span class="sd">            - ``S`` is the **start symbol**, which is a nontermminal</span>
<span class="sd">              symbol and therefore an element of ``N``.</span>
<span class="sd">            - ``P`` is a set of **production rules**, also known as</span>
<span class="sd">              **rewrite rules**. Beginning from the start symbol,</span>
<span class="sd">              these rules can be applied until only terminal symbols</span>
<span class="sd">              are left, which then form a string of the grammar&#39;s</span>
<span class="sd">              language.</span>
<span class="sd">              Different kinds of grammars can be distinguished by</span>
<span class="sd">              putting different restrictions on the form of these rules.</span>
<span class="sd">              This influences how expressive the grammars are and</span>
<span class="sd">              hence what kind of languages can be defined by them.</span>

<span class="sd">        - A **context-free grammar (CFG)** is a type of formal grammar</span>
<span class="sd">          that is frequently used in computer science and programming</span>
<span class="sd">          language design. The production rules need to fulfill</span>
<span class="sd">          following criteria:</span>

<span class="sd">            - The left-hand side of each rule is a single nonterminal</span>
<span class="sd">              symbol. This means a nonterminal symbol can be rewritten</span>
<span class="sd">              into the right-hand side of the rule, no matter which</span>
<span class="sd">              context the nonterminal is surrounded with.</span>
<span class="sd">            - The right-hand side is a sequence of symbols that can</span>
<span class="sd">              consist of a combination of terminal symbols, nonterminal</span>
<span class="sd">              symbols and the empty string ``&quot;&quot;`` (often denoted by</span>
<span class="sd">              the greek letter ``ɛ`` or less often ``λ``).</span>

<span class="sd">    2. Tasks a grammar can be used for</span>

<span class="sd">        - Define a grammar with a text in a suitable format such as</span>
<span class="sd">          Backus-Naur form (BNF) or Extended Backus-Naur form</span>
<span class="sd">          (EBNF). Both of these formats can be recognized by</span>
<span class="sd">          this class&#39;s initialization method `__init__`.</span>
<span class="sd">        - Visualize a grammar in form of a syntax diagram with</span>
<span class="sd">          the method `plot`.</span>
<span class="sd">        - Recognize whether a given string belongs to the grammar&#39;s</span>
<span class="sd">          language or not with the method `recognize_string`.</span>
<span class="sd">        - Parse a given string to see how it can be derived from the</span>
<span class="sd">          start symbol by a specific sequence of rule applications</span>
<span class="sd">          with the method `parse_string`. The result is a parse tree</span>
<span class="sd">          or derivation tree, an instance of the class</span>
<span class="sd">          `~alogos._grammar.data_structures.DerivationTree`.</span>
<span class="sd">          A derivation tree represents a single string by reading</span>
<span class="sd">          its leaf nodes from left to right, but many possible</span>
<span class="sd">          derivations that lead to it, since the sequence of rule</span>
<span class="sd">          applications is not fixed in the tree.</span>
<span class="sd">        - Generate a random derivation, derivation tree or string with</span>
<span class="sd">          the methods `generate_derivation`,</span>
<span class="sd">          `generate_derivation_tree`, `generate_string`.</span>
<span class="sd">        - Generate the grammar&#39;s language or a finite subset of it</span>
<span class="sd">          with the method `generate_language`.</span>
<span class="sd">        - Convert a grammar into a specific normal form or check if it</span>
<span class="sd">          is in one with the methods `to_cnf`, `is_cnf`, `to_gnf`,</span>
<span class="sd">          `is_gnf`, `to_bnf`, `is_bnf`. Normal forms put further</span>
<span class="sd">          restrictions on the form of the production rules, but</span>
<span class="sd">          importantly, converting a grammar into it does not change</span>
<span class="sd">          its language.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The concepts and notation mentioned here are based on</span>
<span class="sd">    classical textbooks in formal language theory such as [1]_.</span>
<span class="sd">    Similar discussions can be found on the web [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. E. Hopcroft and J. D. Ullman, Introduction to</span>
<span class="sd">       Automata Theory, Languages and Computation.</span>
<span class="sd">       Addison-Wesley, 1979.</span>

<span class="sd">    .. [2] Wikipedia articles</span>

<span class="sd">       - `Formal grammar</span>
<span class="sd">         &lt;https://en.wikipedia.org/wiki/Formal_grammar&gt;`__</span>
<span class="sd">       - `Context-free grammar</span>
<span class="sd">         &lt;https://en.wikipedia.org/wiki/Context-free_grammar&gt;`__</span>
<span class="sd">       - `Context-free language</span>
<span class="sd">         &lt;https://en.wikipedia.org/wiki/Context-free_language&gt;`__</span>
<span class="sd">       - `Terminal and nonterminal symbols</span>
<span class="sd">         &lt;https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols&gt;`__</span>
<span class="sd">       - `Production rule</span>
<span class="sd">         &lt;https://en.wikipedia.org/wiki/Production_(computer_science)&gt;`__</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;nonterminal_symbols&quot;</span><span class="p">,</span>
        <span class="s2">&quot;terminal_symbols&quot;</span><span class="p">,</span>
        <span class="s2">&quot;production_rules&quot;</span><span class="p">,</span>
        <span class="s2">&quot;start_symbol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cache&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Initialization and reset</span>
<div class="viewcode-block" id="Grammar.__init__"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">bnf_text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bnf_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ebnf_text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ebnf_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a grammar from a string or file in BNF or EBNF notation.</span>

<span class="sd">        Backus-Naur form (BNF) and Extended Backus-Naur form (EBNF)</span>
<span class="sd">        [3]_ are two well-known and often used formats for defining</span>
<span class="sd">        context-free grammars.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bnf_text : `str`, optional</span>
<span class="sd">            String that contains a grammar in BNF.</span>
<span class="sd">        bnf_file : `str`, optional</span>
<span class="sd">            Filepath of a text file that contains a grammar in BNF.</span>
<span class="sd">        ebnf_text : `str`, optional</span>
<span class="sd">            String that contains a grammar in EBNF.</span>
<span class="sd">        ebnf_file : `str`, optional</span>
<span class="sd">            Filepath of a text file that contains a grammar in EBNF.</span>
<span class="sd">        **kwargs : `dict`, optional</span>
<span class="sd">            Further keyword arguments are forwarded to the function</span>
<span class="sd">            that reads and creates a grammar from text in BNF or EBNF</span>
<span class="sd">            notation. The available arguments and further details can</span>
<span class="sd">            be found in following methods:</span>

<span class="sd">            - BNF: `from_bnf_text`, `from_bnf_file`</span>
<span class="sd">            - EBNF: `from_ebnf_text`, `from_ebnf_file`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If an argument gets a value of unexpected type.</span>

<span class="sd">        FileNotFoundError</span>
<span class="sd">            If a filepath does not point to an existing file.</span>

<span class="sd">        GrammarError</span>
<span class="sd">            If a newly generated grammar does not pass all validity</span>
<span class="sd">            checks. For example, each nonterminal that appears on the</span>
<span class="sd">            right-hand side must also appear on the left-hand side.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        GrammarWarning</span>
<span class="sd">            If a newly generated grammar contains a production rule</span>
<span class="sd">            more than once.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [3] Wikipedia</span>

<span class="sd">           - `Backus-Naur form (BNF)</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form&gt;`__</span>
<span class="sd">           - `Extended Backus-Naur form (EBNF)</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form&gt;`__</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Use text in Backus-Naur form (BNF) to define a grammar:</span>

<span class="sd">        &gt;&gt;&gt; import alogos as al</span>
<span class="sd">        &gt;&gt;&gt; bnf_text = &quot;&quot;&quot;</span>
<span class="sd">        &lt;S&gt; ::= &lt;Greeting&gt; _ &lt;Object&gt; !</span>
<span class="sd">        &lt;Greeting&gt; ::= Hello | Hi | Hola</span>
<span class="sd">        &lt;Object&gt; ::= World | Universe | Cosmos</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; grammar = al.Grammar(bnf_text=bnf_text)</span>
<span class="sd">        &gt;&gt;&gt; grammar.generate_string()</span>
<span class="sd">        Hello_World!</span>

<span class="sd">        Use text in or Extended Backus-Naur form (EBNF) to define a</span>
<span class="sd">        grammar:</span>

<span class="sd">        &gt;&gt;&gt; import alogos as al</span>
<span class="sd">        &gt;&gt;&gt; ebnf_text = &quot;&quot;&quot;</span>
<span class="sd">        S = Greeting &quot; &quot; Object &quot;!&quot;</span>
<span class="sd">        Greeting = &quot;Hello&quot; | &quot;Hi&quot; | &quot;Hola&quot;</span>
<span class="sd">        Object = &quot;World&quot; | &quot;Universe&quot; | &quot;Cosmos&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; grammar = al.Grammar(ebnf_text=ebnf_text)</span>
<span class="sd">        &gt;&gt;&gt; grammar.generate_string()</span>
<span class="sd">        Hola Universe!</span>

<span class="sd">        Use text in an unusual form to define a grammar by passing</span>
<span class="sd">        custom symbol definitions as keyword arguments:</span>

<span class="sd">        &gt;&gt;&gt; import alogos as al</span>
<span class="sd">        &gt;&gt;&gt; bnf_text = &quot;&quot;&quot;</span>
<span class="sd">        [English Sentence] = [Simple Sentence]</span>
<span class="sd">        [Simple Sentence] = [Declarative Sentence]</span>
<span class="sd">        [Declarative Sentence] = [subject] [predicate]</span>
<span class="sd">        [subject] = [simple subject]</span>
<span class="sd">        [simple subject] = [nominative personal pronoun]</span>
<span class="sd">        [nominative personal pronoun] = &quot;I&quot; | &quot;you&quot; | &quot;he&quot; | &quot;she&quot; | &quot;it&quot; | &quot;we&quot; | &quot;they&quot;</span>
<span class="sd">        [predicate] = [verb]</span>
<span class="sd">        [verb] = [linking verb]</span>
<span class="sd">        [linking verb] = &quot;am&quot; |&quot;are&quot; |&quot;is&quot; | &quot;was&quot;| &quot;were&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; grammar = al.Grammar(</span>
<span class="sd">            bnf_text=bnf_text,</span>
<span class="sd">            defining_symbol=&quot;=&quot;,</span>
<span class="sd">            start_nonterminal_symbol=&quot;[&quot;,</span>
<span class="sd">            end_nonterminal_symbol=&quot;]&quot;,</span>
<span class="sd">            start_terminal_symbol=&#39;&quot;&#39;,</span>
<span class="sd">            end_terminal_symbol=&#39;&quot;&#39;,</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; grammar.generate_string(separator=&#39; &#39;)</span>
<span class="sd">        I am</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Argument processing</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">inp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="p">(</span><span class="n">bnf_text</span><span class="p">,</span> <span class="n">bnf_file</span><span class="p">,</span> <span class="n">ebnf_text</span><span class="p">,</span> <span class="n">ebnf_file</span><span class="p">))</span>
            <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="n">_warnings</span><span class="o">.</span><span class="n">_warn_multiple_grammar_specs</span><span class="p">()</span>

        <span class="c1"># Transformation</span>
        <span class="k">if</span> <span class="n">bnf_text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_bnf_text</span><span class="p">(</span><span class="n">bnf_text</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bnf_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_bnf_file</span><span class="p">(</span><span class="n">bnf_file</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ebnf_text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_ebnf_text</span><span class="p">(</span><span class="n">ebnf_text</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ebnf_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_ebnf_file</span><span class="p">(</span><span class="n">ebnf_file</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create an empty grammar if no specification is provided</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_empty_state</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set_empty_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign empty containers for symbols and production rules.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        dict() is used as data structure for rules instead of</span>
<span class="sd">        OrderedDict from the itertools module, and instead of</span>
<span class="sd">        OrderedSet from external orderedset library for symbols,</span>
<span class="sd">        because it guarantees order, is faster and introduces no</span>
<span class="sd">        dependencies and portability issues. Here is more background:</span>

<span class="sd">        - Since Python 3.6, dict in CPython remembers the insertion</span>
<span class="sd">          order of keys.</span>
<span class="sd">        - Since Python 3.7 this is considered a language feature.</span>
<span class="sd">        - If order is not preserved, no algorithm here fails, only</span>
<span class="sd">          output becomes less readable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminal_symbols</span> <span class="o">=</span> <span class="n">_OrderedSet</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonterminal_symbols</span> <span class="o">=</span> <span class="n">_OrderedSet</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">production_rules</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Cache to store results of some calculations instead of repeating them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Copying</span>
<div class="viewcode-block" id="Grammar.copy"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the grammar.</span>

<span class="sd">        The new object is entirely independent of the original object.</span>
<span class="sd">        No parts, such as symbols or rules, are shared between the</span>
<span class="sd">        objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a shallow copy of the grammar.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The content of the `_cache` attribute is not copied.</span>
<span class="sd">        Instead, a new empty dictionary is assigned to it.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/library/copy.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">nonterminal_symbols</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">)</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">terminal_symbols</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">)</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">production_rules</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">production_rules</span><span class="p">)</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">start_symbol</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_grammar</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the grammar.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The content of the `_cache` attribute is not copied.</span>
<span class="sd">        Instead, a new empty dictionary is assigned to it.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/library/copy.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">nonterminal_symbols</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">)</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">terminal_symbols</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">)</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">production_rules</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">production_rules</span><span class="p">)</span>
        <span class="n">new_grammar</span><span class="o">.</span><span class="n">start_symbol</span> <span class="o">=</span> <span class="n">_copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_grammar</span>

    <span class="c1"># Representations</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;official&quot; string representation of the grammar.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__repr__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> object at </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;informal&quot; string representation of the grammar.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__str__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_NEWLINE</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Nonterminal symbols:</span><span class="si">{sep}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">:</span>
            <span class="n">nt_text</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{idx}</span><span class="s2">: </span><span class="si">{nt}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="n">sym</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nt_text</span> <span class="o">=</span> <span class="s2">&quot;Empty set&quot;</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nt_text</span><span class="p">)</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{nl}{nl}</span><span class="s2">Terminal symbols:</span><span class="si">{sep}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nl</span><span class="o">=</span><span class="n">_NEWLINE</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">:</span>
            <span class="n">t_text</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{idx}</span><span class="s2">: </span><span class="si">{terminal}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">terminal</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="n">sym</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_text</span> <span class="o">=</span> <span class="s2">&quot;Empty set&quot;</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_text</span><span class="p">)</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{nl}{nl}</span><span class="s2">Start symbol:</span><span class="si">{sep}{sym}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">nl</span><span class="o">=</span><span class="n">_NEWLINE</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{nl}{nl}</span><span class="s2">Production rules:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nl</span><span class="o">=</span><span class="n">_NEWLINE</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_rules</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_rules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
                    <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{sep}{idx}</span><span class="s2">: </span><span class="si">{lhs}</span><span class="s2"> -&gt; </span><span class="si">{rhs}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span>
                            <span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                            <span class="n">lhs</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span>
                            <span class="n">rhs</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">rhs</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{sep}</span><span class="s2">Empty set&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">))</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide rich display representation for Jupyter notebooks.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://ipython.readthedocs.io/en/stable/config/integrating.html#rich-display</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide rich display representation for IPython.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://ipython.readthedocs.io/en/stable/config/integrating.html#rich-display</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="c1"># Equality and hashing</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute whether two grammars are equal.</span>

<span class="sd">        Caution: This checks if two grammars have identical rules and</span>
<span class="sd">        symbols. It not check for equivalence in the sense of formal</span>
<span class="sd">        language theory, which would mean that two grammars produce</span>
<span class="sd">        the same language. This problem is actually undecidable for</span>
<span class="sd">        context-free grammars in the general case.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__eq__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Type comparison</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># Data comparison</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_rules</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">production_rules</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">lhs1</span><span class="p">,</span> <span class="n">lhs2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lhs1</span> <span class="o">!=</span> <span class="n">lhs2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">rhsm1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="n">lhs1</span><span class="p">]</span>
            <span class="n">rhsm2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="n">lhs2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhsm1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhsm2</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">rhs1</span><span class="p">,</span> <span class="n">rhs2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rhsm1</span><span class="p">,</span> <span class="n">rhsm2</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs2</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">sym1</span><span class="p">,</span> <span class="n">sym2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rhs1</span><span class="p">,</span> <span class="n">rhs2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sym1</span> <span class="o">!=</span> <span class="n">sym2</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a hash value for this object.</span>

<span class="sd">        It is used for operations on hashed collections such as `set`</span>
<span class="sd">        and `dict`.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__hash__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="c1"># Reading</span>
<div class="viewcode-block" id="Grammar.from_bnf_text"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.from_bnf_text">[docs]</a>    <span class="k">def</span> <span class="nf">from_bnf_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bnf_text</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;::=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a grammar specification in BNF notation from a string.</span>

<span class="sd">        This method resets the grammar object and then uses the</span>
<span class="sd">        provided information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bnf_text : `str`</span>
<span class="sd">            String with grammar specification in BNF notation.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        defining_symbol : `str`, optional</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`, optional</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>
<span class="sd">        verbose : `bool`, optional</span>
<span class="sd">            If `True`, messages will be printed during processing the</span>
<span class="sd">            input text that show which rules and symbols are found one</span>
<span class="sd">            after another. This can be useful to see what went wrong</span>
<span class="sd">            when the generated grammar does not look or behave as</span>
<span class="sd">            expected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parsing</span>

        <span class="c1"># Reset this grammar object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_empty_state</span><span class="p">()</span>

        <span class="c1"># Parse BNF</span>
        <span class="n">parsing</span><span class="o">.</span><span class="n">read_bnf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">bnf_text</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Grammar.from_bnf_file"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.from_bnf_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_bnf_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;::=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a grammar specification in BNF notation from a file.</span>

<span class="sd">        This method resets the grammar object and then uses the</span>
<span class="sd">        provided information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : `str`</span>
<span class="sd">            Text file with grammar specification in BNF notation.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        defining_symbol : `str`, optional</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`, optional</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>
<span class="sd">        verbose : `bool`, optional</span>
<span class="sd">            If `True`, messages will be printed during processing the</span>
<span class="sd">            input text that show which rules and symbols are found one</span>
<span class="sd">            after another. This can be useful to see what went wrong</span>
<span class="sd">            when the generated grammar does not look or behave as</span>
<span class="sd">            expected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Argument processing</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;filepath&quot;</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Read text from file</span>
        <span class="n">bnf_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Transform BNF text to grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_bnf_text</span><span class="p">(</span>
            <span class="n">bnf_text</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Grammar.from_ebnf_text"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.from_ebnf_text">[docs]</a>    <span class="k">def</span> <span class="nf">from_ebnf_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ebnf_text</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a grammar specification in EBNF notation from a string.</span>

<span class="sd">        This method resets the grammar object and then uses the</span>
<span class="sd">        provided information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ebnf_text : `str`</span>
<span class="sd">            String with grammar specification in EBNF notation.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        defining_symbol : `str`, optional</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`, optional</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>
<span class="sd">        verbose : `bool`, optional</span>
<span class="sd">            If `True`, messages will be printed during processing the</span>
<span class="sd">            input text that show which rules and symbols are found one</span>
<span class="sd">            after another. This can be useful to see what went wrong</span>
<span class="sd">            when the generated grammar does not look or behave as</span>
<span class="sd">            expected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parsing</span>

        <span class="c1"># Reset this grammar object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_empty_state</span><span class="p">()</span>

        <span class="c1"># Parse EBNF</span>
        <span class="n">parsing</span><span class="o">.</span><span class="n">read_ebnf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ebnf_text</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Grammar.from_ebnf_file"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.from_ebnf_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_ebnf_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a grammar specification in EBNF notation from a file.</span>

<span class="sd">        This method resets the grammar object and then uses the</span>
<span class="sd">        provided information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : `str`</span>
<span class="sd">            Text file with grammar specification in EBNF notation.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        defining_symbol : `str`, optional</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`, optional</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>
<span class="sd">        verbose : `bool`, optional</span>
<span class="sd">            If `True`, messages will be printed during processing the</span>
<span class="sd">            input text that show which rules and symbols are found one</span>
<span class="sd">            after another. This can be useful to see what went wrong</span>
<span class="sd">            when the generated grammar does not look or behave as</span>
<span class="sd">            expected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Argument processing</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;filepath&quot;</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Read text from file</span>
        <span class="n">ebnf_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Transform EBNF text to grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_ebnf_text</span><span class="p">(</span>
            <span class="n">ebnf_text</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="c1"># Writing</span>
<div class="viewcode-block" id="Grammar.to_bnf_text"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.to_bnf_text">[docs]</a>    <span class="k">def</span> <span class="nf">to_bnf_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rules_on_separate_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;::=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the grammar in BNF notation to a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rule_on_separate_lines : `bool`, optional</span>
<span class="sd">            If `True`, each rule for a nonterminal is put onto a</span>
<span class="sd">            separate line. If `False`, all rules for a nonterminal</span>
<span class="sd">            are grouped onto one line.</span>
<span class="sd">        defining_symbol : `str`, optional</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`, optional</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parsing</span>

        <span class="c1"># Generate BNF text</span>
        <span class="n">bnf_text</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">write_bnf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">rules_on_separate_lines</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bnf_text</span></div>

<div class="viewcode-block" id="Grammar.to_bnf_file"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.to_bnf_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_bnf_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">,</span>
        <span class="n">rules_on_separate_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;::=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the grammar in BNF notation to a text file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : `str`</span>
<span class="sd">            Filepath of the text file that shall be generated.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        rule_on_separate_lines : `bool`, optional</span>
<span class="sd">            If `True`, each rule for a nonterminal is put onto a</span>
<span class="sd">            separate line. If `False`, all rules for a nonterminal</span>
<span class="sd">            are grouped onto one line.</span>
<span class="sd">        defining_symbol : `str`, optional</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Argument processing</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;filepath&quot;</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Generate BNF text</span>
        <span class="n">bnf_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bnf_text</span><span class="p">(</span>
            <span class="n">rules_on_separate_lines</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Write text to file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">bnf_text</span><span class="p">)</span></div>

<div class="viewcode-block" id="Grammar.to_ebnf_text"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.to_ebnf_text">[docs]</a>    <span class="k">def</span> <span class="nf">to_ebnf_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rules_on_separate_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the grammar in EBNF notation to a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rule_on_separate_lines : `bool`</span>
<span class="sd">            If `True`, each rule for a nonterminal is put onto a</span>
<span class="sd">            separate line. If `False`, all rules for a nonterminal</span>
<span class="sd">            are grouped onto one line.</span>
<span class="sd">        defining_symbol : `str`</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parsing</span>

        <span class="c1"># Generate EBNF text</span>
        <span class="n">ebnf_text</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">write_ebnf</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">rules_on_separate_lines</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ebnf_text</span></div>

<div class="viewcode-block" id="Grammar.to_ebnf_file"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.to_ebnf_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_ebnf_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">,</span>
        <span class="n">rules_on_separate_lines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">defining_symbol</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">,</span>
        <span class="n">rule_separator_symbol</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">start_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end_nonterminal_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">start_terminal_symbol2</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="n">end_terminal_symbol2</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the grammar in EBNF notation to a text file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : `str`</span>
<span class="sd">            Filepath of the text file that shall be generated.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        rule_on_separate_lines : `bool`, optional</span>
<span class="sd">            If `True`, each rule for a nonterminal is put onto a</span>
<span class="sd">            separate line. If `False`, all rules for a nonterminal</span>
<span class="sd">            are grouped onto one line.</span>
<span class="sd">        defining_symbol : `str`, optional</span>
<span class="sd">            Symbol between left-hand side and right-hand side of a rule.</span>
<span class="sd">        rule_separator_symbol : `str`, optional</span>
<span class="sd">            Symbol between alternative productions of a rule.</span>
<span class="sd">        start_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a nonterminal.</span>
<span class="sd">        end_nonterminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a nonterminal.</span>
<span class="sd">        start_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol : `str`, optional</span>
<span class="sd">            Symbol indicating the end of a terminal.</span>
<span class="sd">        start_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the start of a terminal.</span>
<span class="sd">        end_terminal_symbol2 : `str`, optional</span>
<span class="sd">            Alternative symbol indicating the end of a terminal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Argument processing</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;filepath&quot;</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Generate EBNF text</span>
        <span class="n">ebnf_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_ebnf_text</span><span class="p">(</span>
            <span class="n">rules_on_separate_lines</span><span class="p">,</span>
            <span class="n">defining_symbol</span><span class="p">,</span>
            <span class="n">rule_separator_symbol</span><span class="p">,</span>
            <span class="n">start_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">end_nonterminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol</span><span class="p">,</span>
            <span class="n">end_terminal_symbol</span><span class="p">,</span>
            <span class="n">start_terminal_symbol2</span><span class="p">,</span>
            <span class="n">end_terminal_symbol2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Write text to file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">ebnf_text</span><span class="p">)</span></div>

    <span class="c1"># String generation</span>
<div class="viewcode-block" id="Grammar.generate_derivation_tree"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.generate_derivation_tree">[docs]</a>    <span class="k">def</span> <span class="nf">generate_derivation_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a derivation tree with a chosen method.</span>

<span class="sd">        One *derivation tree* represents one *string* but many</span>
<span class="sd">        *derivations* [4]_.</span>

<span class="sd">        - The leaf nodes of the tree read from left to right form a</span>
<span class="sd">          string of the language defined by the grammar.</span>
<span class="sd">        - A depth-first walk over the tree that always chooses the</span>
<span class="sd">          leftmost item gives the leftmost derivation, while one that</span>
<span class="sd">          always chooses the rightmost item gives the rightmost</span>
<span class="sd">          derivation. In most cases, there can be many more ways to</span>
<span class="sd">          expand one nonterminal after another, leading to a plethora</span>
<span class="sd">          of possible derivations, all represented by the same</span>
<span class="sd">          derivation tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : `str`, optional</span>
<span class="sd">            Name of the method that is used for creating a</span>
<span class="sd">            derivation tree.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            - Deterministic methods that require the keyword argument</span>
<span class="sd">              ``genotype`` as input data:</span>

<span class="sd">                - ``&quot;cfggp&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems.cfggp.mapping.forward`</span>
<span class="sd">                  mapping from CFG-GP.</span>
<span class="sd">                - ``&quot;cfggpst&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems.cfggpst.mapping.forward`</span>
<span class="sd">                  mapping from CFG-GP-ST.</span>
<span class="sd">                - ``&quot;dsge&quot;``: Uses `~alogos.systems.dsge.mapping.forward`</span>
<span class="sd">                  mapping from DSGE.</span>
<span class="sd">                - ``&quot;ge&quot;``: Uses `~alogos.systems.ge.mapping.forward`</span>
<span class="sd">                  mapping from GE.</span>
<span class="sd">                - ``&quot;pige&quot;``: Uses `~alogos.systems.pige.mapping.forward`</span>
<span class="sd">                  mapping from piGE.</span>
<span class="sd">                - ``&quot;whge&quot;``: Uses `~alogos.systems.whge.mapping.forward`</span>
<span class="sd">                  mapping from WHGE.</span>

<span class="sd">            - Probabilistic methods that generate a random tree and</span>
<span class="sd">              require no input data:</span>

<span class="sd">                - ``&quot;uniform&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems._shared.init_tree.uniform`.</span>

<span class="sd">                - ``&quot;weighted&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems._shared.init_tree.weighted`.</span>

<span class="sd">                - ``&quot;ptc2&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems._shared.init_tree.ptc2`.</span>

<span class="sd">                - ``&quot;grow_one_branch_to_max_depth&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems._shared.init_tree.grow_one_branch_to_max_depth`.</span>

<span class="sd">                - ``&quot;grow_all_branches_within_max_depth&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems._shared.init_tree.grow_all_branches_within_max_depth`</span>

<span class="sd">                - ``&quot;grow_all_branches_to_max_depth&quot;``: Uses</span>
<span class="sd">                  `~alogos.systems._shared.init_tree.grow_all_branches_to_max_depth`.</span>

<span class="sd">        **kwargs : `dict`, optional</span>
<span class="sd">            Further keyword arguments are forwarded to the chosen</span>
<span class="sd">            method. This is especially relevant for controlling the</span>
<span class="sd">            behavior of the probabilistic methods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        derivation_tree : `~alogos._grammar.data_structures.DerivationTree`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        MappingError</span>
<span class="sd">            If the method fails to generate a derivation tree,</span>
<span class="sd">            e.g. because a limit like maximum number of expansions</span>
<span class="sd">            was reached before all leaves contained terminal symbols</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [4] Wikipedia</span>

<span class="sd">           - `Parse tree</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Parse_tree&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Argument processing</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">systems</span>

        <span class="n">name_method_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># Deterministic derivations with G3P mapping functions</span>
            <span class="s2">&quot;cfggp&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">cfggp</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span>
            <span class="s2">&quot;cfggpst&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">cfggpst</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span>
            <span class="s2">&quot;dsge&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">dsge</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span>
            <span class="s2">&quot;ge&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">ge</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span>
            <span class="s2">&quot;pige&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">pige</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span>
            <span class="s2">&quot;whge&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">whge</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">forward</span><span class="p">,</span>
            <span class="c1"># Probabilistic derivations with random rule selection schemes</span>
            <span class="s2">&quot;uniform&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">_shared</span><span class="o">.</span><span class="n">init_tree</span><span class="o">.</span><span class="n">uniform</span><span class="p">,</span>
            <span class="s2">&quot;weighted&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">_shared</span><span class="o">.</span><span class="n">init_tree</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
            <span class="s2">&quot;grow_one_branch_to_max_depth&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">_shared</span><span class="o">.</span><span class="n">init_tree</span><span class="o">.</span><span class="n">grow_one_branch_to_max_depth</span><span class="p">,</span>
            <span class="s2">&quot;grow_all_branches_within_max_depth&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">_shared</span><span class="o">.</span><span class="n">init_tree</span><span class="o">.</span><span class="n">grow_all_branches_within_max_depth</span><span class="p">,</span>
            <span class="s2">&quot;grow_all_branches_to_max_depth&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">_shared</span><span class="o">.</span><span class="n">init_tree</span><span class="o">.</span><span class="n">grow_all_branches_to_max_depth</span><span class="p">,</span>
            <span class="s2">&quot;ptc2&quot;</span><span class="p">:</span> <span class="n">systems</span><span class="o">.</span><span class="n">_shared</span><span class="o">.</span><span class="n">init_tree</span><span class="o">.</span><span class="n">ptc2</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">name_method_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">name_method_map</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>

        <span class="c1"># Mapping</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;cfggp&quot;</span><span class="p">,</span> <span class="s2">&quot;cfggpst&quot;</span><span class="p">,</span> <span class="s2">&quot;dsge&quot;</span><span class="p">,</span> <span class="s2">&quot;ge&quot;</span><span class="p">,</span> <span class="s2">&quot;pige&quot;</span><span class="p">,</span> <span class="s2">&quot;whge&quot;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;return_derivation_tree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dt</span></div>

<div class="viewcode-block" id="Grammar.generate_derivation"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.generate_derivation">[docs]</a>    <span class="k">def</span> <span class="nf">generate_derivation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">derivation_order</span><span class="o">=</span><span class="s2">&quot;leftmost&quot;</span><span class="p">,</span>
        <span class="n">newline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a derivation with a chosen method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : `str`, optional</span>
<span class="sd">            Name of the method that is used for creating a derivation.</span>

<span class="sd">            Possible values: See `generate_derivation_tree`.</span>
<span class="sd">        derivation_order : `str`, optional</span>
<span class="sd">            Order in which nonterminals are expanded during the step-by-step derivation.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            - ``&quot;leftmost&quot;``: Expand the leftmost nonterminal in each step.</span>
<span class="sd">            - ``&quot;rightmost&quot;``: Expand the rightmost nonterminal in each step.</span>
<span class="sd">            - ``&quot;random&quot;``: Expand a random nonterminal in each step.</span>

<span class="sd">        newline : `bool`, optional</span>
<span class="sd">             If `True`, the derivation steps are placed on separate</span>
<span class="sd">             lines by adding newline characters between them.</span>
<span class="sd">        **kwargs : `dict`, optional</span>
<span class="sd">            Further keyword arguments are forwarded to the chosen</span>
<span class="sd">            method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        derivation : `str`</span>
<span class="sd">            The derivation generated with the chosen method.</span>
<span class="sd">            It is a text that shows each step of the derivation</span>
<span class="sd">            as it is commonly represented in textbooks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method uses `generate_derivation_tree` to create a</span>
<span class="sd">        derivation tree and then reads the leftmost derivation</span>
<span class="sd">        contained in it with</span>
<span class="sd">        `~alogos._grammar.data_structures.DerivationTree.derivation`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_derivation_tree</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">derivation</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">derivation</span><span class="p">(</span><span class="n">derivation_order</span><span class="o">=</span><span class="n">derivation_order</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="n">newline</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">derivation</span></div>

<div class="viewcode-block" id="Grammar.generate_string"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.generate_string">[docs]</a>    <span class="k">def</span> <span class="nf">generate_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;weighted&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a string with a chosen method.</span>

<span class="sd">        Each string [5]_ is part of the language L(G) defined by grammar G.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : `str`, optional</span>
<span class="sd">            Name of the method that is used for creating a string.</span>

<span class="sd">            Possible values: See `generate_derivation_tree`.</span>
<span class="sd">        separator : `str`, optional</span>
<span class="sd">            A short string that is inserted between each of the</span>
<span class="sd">            terminal symbols that make up the string of the grammar&#39;s</span>
<span class="sd">            language.</span>
<span class="sd">        **kwargs : `dict`, optional</span>
<span class="sd">            Further keyword arguments are forwarded to the chosen</span>
<span class="sd">            method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        string : `str`</span>
<span class="sd">            The string generated with the chosen method.</span>
<span class="sd">            It is a text that consists only of terminal symbols</span>
<span class="sd">            and optionally a separator symbol between them.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method uses `generate_derivation_tree` to create a</span>
<span class="sd">        derivation tree and then reads the string contained in it</span>
<span class="sd">        from the leaf nodes with</span>
<span class="sd">        `~alogos._grammar.data_structures.DerivationTree.string`.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [5] Wikipedia</span>

<span class="sd">           - `String &lt;https://en.wikipedia.org/wiki/String_(computer_science)&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_derivation_tree</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span></div>

<div class="viewcode-block" id="Grammar.generate_language"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.generate_language">[docs]</a>    <span class="k">def</span> <span class="nf">generate_language</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_order</span><span class="o">=</span><span class="s2">&quot;discovered&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_details</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate the formal language defined by the grammar.</span>

<span class="sd">        This algorithm recursively constructs the formal language [6]_</span>
<span class="sd">        defined by the grammar, i.e. the set of strings it can generate</span>
<span class="sd">        or recognize.</span>

<span class="sd">        The algorithm can be stopped prematurely to get only a subset</span>
<span class="sd">        of the entire language. By default, only the language of the</span>
<span class="sd">        start symbol is returned, which is the language of the grammar,</span>
<span class="sd">        but it is also possible to return the languages of each other</span>
<span class="sd">        nonterminal symbol, which can be thought of as sublanguages.</span>
<span class="sd">        For example, many programming languages are defined by a CFG</span>
<span class="sd">        and have a nonterminal symbol that represents all valid integer</span>
<span class="sd">        literals in that language.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_steps : `int`, optional</span>
<span class="sd">            The maximum number of recursive steps during language</span>
<span class="sd">            generation. It can be used to stop the algorithm before it</span>
<span class="sd">            can construct all strings of the language. Instead a list of</span>
<span class="sd">            valid strings found so far will be returned, which is a</span>
<span class="sd">            subset of the entire language. This is necessary to get a</span>
<span class="sd">            result if the grammar defines a very large or infinite</span>
<span class="sd">            language.</span>

<span class="sd">            Note that each recursive step uses the strings known so far</span>
<span class="sd">            and inserts them into the right-hand sides of production</span>
<span class="sd">            rules to see if any new strings can be discovered. Therefore</span>
<span class="sd">            simpler strings are found before more complex ones that</span>
<span class="sd">            require more expansions. If the number of steps is too</span>
<span class="sd">            little to form a single string belonging to the language of</span>
<span class="sd">            the start symbol, the result will be an empty list.</span>
<span class="sd">        sort_order : `str`, optional</span>
<span class="sd">            The language is returned as a list of strings, which can be</span>
<span class="sd">            sorted in different ways.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            - ``&quot;discovered&quot;``: Strings are returned in the order they</span>
<span class="sd">              were discovered.</span>
<span class="sd">            - ``&quot;lex&quot;``: Lexicographic, i.e. the order used in lexicons,</span>
<span class="sd">              which means the alphabetic order extended to non-alphabet</span>
<span class="sd">              characters like numbers. Python&#39;s built-in ``sort()``</span>
<span class="sd">              function delivers it by default.</span>
<span class="sd">            - ``&quot;shortlex&quot;``: Strings are sorted primarily by their</span>
<span class="sd">              length. Those with the same length are further sorted in</span>
<span class="sd">              lexicographic order.</span>
<span class="sd">        verbose : `bool`, optional</span>
<span class="sd">            If `True`, detailed messages are printed during language</span>
<span class="sd">            generation. If `False`, no output is generated.</span>
<span class="sd">        return_details : `bool`, optional</span>
<span class="sd">            If `True`, the return value is a `dict` with nonterminals</span>
<span class="sd">            as keys and their languages as values. The language of the</span>
<span class="sd">            start symbol is the language of the grammar, but each</span>
<span class="sd">            nonterminal has its own sub-language that can be of interest</span>
<span class="sd">            too.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        language : `list` of `str`, or `dict` with `list` of `str` as values</span>
<span class="sd">            The formal language L(G) defined by the grammar G.</span>
<span class="sd">            If the argument `return_details` is set to `True`,</span>
<span class="sd">            the return value is a `dict` where each key is a nonterminal</span>
<span class="sd">            of the grammar and each value the language (set of strings)</span>
<span class="sd">            of the nonterminal.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        GrammarWarning</span>
<span class="sd">            If no value is provided for the argument `max_steps`,</span>
<span class="sd">            internally an unrealistically large value of is assigned to</span>
<span class="sd">            it. In the unlikely case this is ever reached, a warning</span>
<span class="sd">            will be raised if the language generation did not generate</span>
<span class="sd">            all strings of the language.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [6] Wikipedia</span>

<span class="sd">           - `Formal language</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Formal_language&gt;`__</span>
<span class="sd">           - `Shortlex order</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Shortlex_order&gt;`__</span>
<span class="sd">           - `Lexicographic order</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Lexicographical_order&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">generation</span>

        <span class="n">strings</span> <span class="o">=</span> <span class="n">generation</span><span class="o">.</span><span class="n">generate_language</span><span class="p">(</span>
            <span class="n">grammar</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">sort_order</span><span class="o">=</span><span class="n">sort_order</span><span class="p">,</span>
            <span class="n">max_steps</span><span class="o">=</span><span class="n">max_steps</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_details</span><span class="o">=</span><span class="n">return_details</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">strings</span></div>

    <span class="c1"># String parsing</span>
<div class="viewcode-block" id="Grammar.recognize_string"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.recognize_string">[docs]</a>    <span class="k">def</span> <span class="nf">recognize_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="s2">&quot;earley&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if a string belongs to the language of the grammar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        string : `str`</span>
<span class="sd">            Candidate string which can be recognized to be a member of</span>
<span class="sd">            the grammar&#39;s language.</span>
<span class="sd">        parser : `str`, optional</span>
<span class="sd">            Parsing algorithm used to analyze the string.</span>

<span class="sd">            Possible values: See `parse_string`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        recognized : `bool`</span>
<span class="sd">            `True` if the string belongs to the grammar&#39;s language,</span>
<span class="sd">            `False` if it does not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">get_multiple_trees</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">_exceptions</span><span class="o">.</span><span class="n">ParserError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Grammar.parse_string"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.parse_string">[docs]</a>    <span class="k">def</span> <span class="nf">parse_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="s2">&quot;earley&quot;</span><span class="p">,</span> <span class="n">get_multiple_trees</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_num_trees</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to parse a given string with a chosen parsing algorithm.</span>

<span class="sd">        Parsing means the analysis of a string into its parts or</span>
<span class="sd">        constituents [7]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        string : `str`</span>
<span class="sd">            Candidate string which can only be parsed successfully</span>
<span class="sd">            if it is a member of the grammar&#39;s language.</span>
<span class="sd">        parser : `str`, optional</span>
<span class="sd">            Parsing algorithm used to analyze the string. This package</span>
<span class="sd">            uses parsers from the package Lark [8]_.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            - ``&quot;earley&quot;``: Can parse any context-free grammar.</span>

<span class="sd">              Performance: The algorithm has a time complexity of</span>
<span class="sd">              ``O(n^3)``, but if the grammar is unambiguous it is</span>
<span class="sd">              reduced to ``O(n^2)`` and for most LR grammars it</span>
<span class="sd">              is ``O(n)``.</span>

<span class="sd">            - ``&quot;lalr&quot;``: Can parse only a subset of context-free</span>
<span class="sd">              grammars, which have a form that allows very efficient</span>
<span class="sd">              parsing with a LALR(1) parser.</span>

<span class="sd">              Performance: The algorithm has a time complexity</span>
<span class="sd">              of ``O(n)``.</span>
<span class="sd">        get_multiple_trees : `bool`, optional</span>
<span class="sd">            If `True`, a list of parse trees, also known as</span>
<span class="sd">            parse forest, is returned instead of a single</span>
<span class="sd">            parse tree object.</span>
<span class="sd">        max_num_trees : `int`, optional</span>
<span class="sd">            An upper limit on how many parse trees will be returned at</span>
<span class="sd">            maximum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        parse_tree : `~alogos._grammar.data_structures.DerivationTree`, or `list` of `~alogos._grammar.data_structures.DerivationTree`</span>
<span class="sd">            If the argument `get_multiple_trees` is set to `True`,</span>
<span class="sd">            a list of derivation trees is returned instead of a single</span>
<span class="sd">            derivation tree object. The list can contain one or more</span>
<span class="sd">            trees, dependening on how many ways there are to parse the</span>
<span class="sd">            given string. If a grammar is unambiguous, there is only</span>
<span class="sd">            one way. If it is ambuguous, there can be multiple ways</span>
<span class="sd">            to derive the same string in a leftmost derivation, which</span>
<span class="sd">            is captured by different derivation trees.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        `ParserError`</span>
<span class="sd">            If the string does not belong to the language and therefore</span>
<span class="sd">            no parse tree exists for it.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the grammar is ambiguous, there can be more than one way</span>
<span class="sd">        to parse a given string, which means that there are multiple</span>
<span class="sd">        parse trees for it. By default, only one of these trees is</span>
<span class="sd">        returned, but the argument ``get_multiple_trees`` allows to</span>
<span class="sd">        get all of them. Caution: This feature is currently only</span>
<span class="sd">        supported with Lark&#39;s Earley parser.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [7] Wikipedia</span>

<span class="sd">           - `Parsing</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Parsing&gt;`__</span>
<span class="sd">           - `Earley parser</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Earley_parser&gt;`__</span>
<span class="sd">           - `LALR parser</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/LALR_parser&gt;`__</span>
<span class="sd">           - `Ambiguous grammar</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Ambiguous_grammar&gt;`__</span>

<span class="sd">        .. [8] `Lark &lt;https://lark-parser.readthedocs.io&gt;`__</span>

<span class="sd">           - `Earley &lt;https://lark-parser.readthedocs.io/en/latest/parsers.html#earley&gt;`__</span>
<span class="sd">           - `LALR(1) &lt;https://lark-parser.readthedocs.io/en/latest/parsers.html#lalr-1&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parsing</span>

        <span class="c1"># Parse with lark-parser</span>
        <span class="n">derivation_tree</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span>
            <span class="n">grammar</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">string</span><span class="o">=</span><span class="n">string</span><span class="p">,</span>
            <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span>
            <span class="n">get_multiple_trees</span><span class="o">=</span><span class="n">get_multiple_trees</span><span class="p">,</span>
            <span class="n">max_num_trees</span><span class="o">=</span><span class="n">max_num_trees</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">derivation_tree</span></div>

    <span class="c1"># Visualization</span>
<div class="viewcode-block" id="Grammar.plot"><a class="viewcode-back" href="../../../autoapi/alogos/index.html#alogos._grammar.data_structures.Grammar.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a figure containing a syntax diagram of the grammar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : `Figure`</span>
<span class="sd">            Figure object containing the plot, allowing to display or</span>
<span class="sd">            export it.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Syntax diagrams (a.k.a. railroad diagrams) [9]_ are especially</span>
<span class="sd">        useful for representing EBNF specifications of a grammar,</span>
<span class="sd">        because they capture nicely the extended notations that are</span>
<span class="sd">        introduced by EBNF, e.g. optional or repeated items.</span>

<span class="sd">        This package supports reading a grammar specification from</span>
<span class="sd">        EBNF text. Internally, however, EBNF is automatically converted</span>
<span class="sd">        to a simpler form during the reading process, which is done by</span>
<span class="sd">        removing any occurrence of extended notation and expressing it</span>
<span class="sd">        with newly introduced symbols and rules instead. Only the final</span>
<span class="sd">        version of the grammar can be visualized, which is essentially</span>
<span class="sd">        BNF with new helper rules and nonterminals. Therefore the</span>
<span class="sd">        expressive power of syntax diagrams is unfortunately not fully</span>
<span class="sd">        used here.</span>

<span class="sd">        There are many websites with explanations [10]_ or</span>
<span class="sd">        examples [11]_ of syntax diagrams.</span>
<span class="sd">        Likewise, there are many libraries [12]_ for generating</span>
<span class="sd">        syntax diagrams. This package uses the library</span>
<span class="sd">        Railroad-Diagram Generator [13]_.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [9] Wikipedia</span>

<span class="sd">           - `Syntax diagram</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Syntax_diagram&gt;`__</span>

<span class="sd">        .. [10] Explanatory websites</span>

<span class="sd">           - Oxford Reference / A Dictionary of Computing 6th edition:</span>
<span class="sd">             `Syntax diagram</span>
<span class="sd">             &lt;https://www.oxfordreference.com/view/10.1093/oi/authority.20110803100547820&gt;`__</span>
<span class="sd">           - Course website by Roger Hartley:</span>
<span class="sd">             `Programming language structure 1: Syntax diagrams</span>
<span class="sd">             &lt;https://www.cs.nmsu.edu/~rth/cs/cs471/Syntax%20Module/diagrams.html&gt;`__</span>
<span class="sd">           - Book chapter by Richard E. Pattis with Syntax Charts</span>
<span class="sd">             on p. 11:</span>
<span class="sd">             `v1: Languages and Syntax</span>
<span class="sd">             &lt;http://www.cs.cmu.edu/~pattis/misc/ebnf.pdf&gt;`__,</span>
<span class="sd">             `v2: EBNF - A Notation to Describe Syntax</span>
<span class="sd">             &lt;https://www.ics.uci.edu/~pattis/misc/ebnf2.pdf&gt;`__</span>

<span class="sd">        .. [11] Example websites</span>

<span class="sd">           - `xkcd webcomic &lt;https://xkcd.com/1930/&gt;`__</span>
<span class="sd">           - `JSON &lt;https://www.json.org/json-en.html&gt;`__</span>
<span class="sd">           - `SQLite &lt;https://www.sqlite.org/lang.html&gt;`__</span>
<span class="sd">           - `Oracle Database Lite SQL &lt;https://docs.oracle.com/cd/B19188_01/doc/B15917/sqsyntax.htm&gt;`__</span>
<span class="sd">           - `Boost &lt;https://www.boost.org/doc/libs/1_66_0/libs/spirit/doc/html/spirit/abstracts/syntax_diagram.html&gt;`__</span>

<span class="sd">        .. [12] Some other tools for drawing syntax diagrams</span>

<span class="sd">           - `Railroad Diagram Generator</span>
<span class="sd">             &lt;https://bottlecaps.de/rr/ui&gt;`__</span>
<span class="sd">             by Gunther Rademacher</span>
<span class="sd">           - `ANTLR Development Tools</span>
<span class="sd">             &lt;https://www.antlr.org/tools.html&gt;`__</span>
<span class="sd">             by Terence Parr</span>
<span class="sd">           - `DokuWiki EBNF Plugin</span>
<span class="sd">             &lt;https://www.dokuwiki.org/plugin:ebnf&gt;`__</span>
<span class="sd">             by Vincent Tscherter</span>
<span class="sd">           - `bubble-generator</span>
<span class="sd">             &lt;https://www.sqlite.org/docsrc/finfo?name=art/syntax/bubble-generator.tcl&gt;`__</span>
<span class="sd">             by the SQLite team</span>
<span class="sd">           - `Ebnf2ps &lt;https://github.com/FranklinChen/Ebnf2ps&gt;`__</span>
<span class="sd">             by Peter Thiemann</span>
<span class="sd">           - `EBNF Visualizer</span>
<span class="sd">             &lt;http://dotnet.jku.at/applications/Visualizer/&gt;`__</span>
<span class="sd">             by Markus Dopler and Stefan Schörgenhumer</span>
<span class="sd">           - `Clapham Railroad Diagram Generator</span>
<span class="sd">             &lt;http://clapham.hydromatic.net&gt;`__</span>
<span class="sd">             by Julian Hyde</span>
<span class="sd">           - `draw-grammar</span>
<span class="sd">             &lt;https://github.com/iangodin/draw-grammar&gt;`__</span>
<span class="sd">             by Ian Godin</span>

<span class="sd">        .. [13] Library used here for generating syntax diagram SVGs</span>

<span class="sd">           - `Railroad-Diagram Generator</span>
<span class="sd">             &lt;https://github.com/tabatkins/railroad-diagrams&gt;`__</span>
<span class="sd">             by Tab Atkins Jr.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">visualization</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">visualization</span><span class="o">.</span><span class="n">create_syntax_diagram</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

    <span class="c1"># Normal forms</span>
    <span class="k">def</span> <span class="nf">_is_cnf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if this grammar is in Chomsky Normal Form (CNF).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_cnf : `bool`</span>
<span class="sd">            `True` if it is in CNF, `False` otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">normalization</span>

        <span class="k">return</span> <span class="n">normalization</span><span class="o">.</span><span class="n">is_cnf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_cnf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the grammar to Chomsky Normal Form (CNF).</span>

<span class="sd">        This normal form was originally defined by Noam Chomsky [14]_.</span>
<span class="sd">        Modern definitions and algorithms can be found in standard</span>
<span class="sd">        textbooks of formal language theory [15]_, [16]_ and on the</span>
<span class="sd">        web [17]_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grammar_in_cnf : `Grammar`</span>
<span class="sd">            New grammar object where all rules adhere to CNF.</span>
<span class="sd">            It is equivalent to the original grammar, which means</span>
<span class="sd">            that it generates the same language.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assuming that the grammar does not have the empty string as</span>
<span class="sd">        part of its language, then all rules need to be in one of</span>
<span class="sd">        the following two forms:</span>

<span class="sd">        - ``X → a``, where ``a`` is a terminal</span>
<span class="sd">        - ``X → BC``, where ``B`` and ``C`` are nonterminals</span>

<span class="sd">        Tasks that are simplified by having a grammar in CNF:</span>

<span class="sd">        - Deciding if a given string is part of the grammar&#39;s language</span>
<span class="sd">        - Parsing with efficient data structures for binary trees</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [14] N. Chomsky, “On certain formal properties of grammars,”</span>
<span class="sd">           Information and Control, vol. 2, no. 2, pp. 137–167,</span>
<span class="sd">           Jun. 1959.</span>

<span class="sd">        .. [15] J. E. Hopcroft and J. D. Ullman, Introduction to</span>
<span class="sd">           Automata Theory, Languages and Computation.</span>
<span class="sd">           Addison-Wesley, 1979, pp. 92-94.</span>

<span class="sd">        .. [16] E. A. Rich, Automata, Computability and Complexity:</span>
<span class="sd">           Theory and Applications. Pearson Education, 2007, p. 169.</span>

<span class="sd">        .. [17] Wikipedia</span>

<span class="sd">           - `Chomsky normal form</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Chomsky_normal_form&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">normalization</span>

        <span class="k">return</span> <span class="n">normalization</span><span class="o">.</span><span class="n">to_cnf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_gnf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if this grammar is in Greibach Normal Form (GNF).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_gnf : `bool`</span>
<span class="sd">            `True` if it is in GNF, `False` otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">normalization</span>

        <span class="k">return</span> <span class="n">normalization</span><span class="o">.</span><span class="n">is_gnf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_gnf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert this grammar to Greibach Normal Form (GNF).</span>

<span class="sd">        This normal form was originally defined by</span>
<span class="sd">        Sheila A. Greibach [18]_.</span>
<span class="sd">        Modern definitions and algorithms can be found in standard</span>
<span class="sd">        textbooks of formal language theory [19]_, [20]_ and on the</span>
<span class="sd">        web [21]_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grammar_in_cnf : `Grammar`</span>
<span class="sd">            New grammar object where all rules adhere to GNF.</span>
<span class="sd">            It is equivalent to the original grammar, which means</span>
<span class="sd">            that it generates the same language.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All rules need to be in the following form:</span>

<span class="sd">        - ``X → B`` where ``B`` is a nonterminal and ``a`` is a terminal</span>

<span class="sd">        Tasks that are simplified by having a grammar in GNF:</span>

<span class="sd">        - Deciding if a given string is part of the grammar&#39;s language</span>
<span class="sd">        - Converting the grammar to a pushdown automaton (PDA) without</span>
<span class="sd">          ε-transitions, which is useful because it is guaranteed to</span>
<span class="sd">          halt.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [18] S. A. Greibach, “A New Normal-Form Theorem for</span>
<span class="sd">           Context-Free Phrase Structure Grammars,”</span>
<span class="sd">           J. ACM, vol. 12, no. 1, pp. 42–52, Jan. 1965.</span>

<span class="sd">        .. [19] J. E. Hopcroft and J. D. Ullman, Introduction to</span>
<span class="sd">           Automata Theory, Languages and Computation.</span>
<span class="sd">           Addison-Wesley, 1979, pp. 94-99.</span>

<span class="sd">        .. [20] E. A. Rich, Automata, Computability and Complexity:</span>
<span class="sd">           Theory and Applications. Pearson Education, 2007, p. 169.</span>

<span class="sd">        .. [21] Wikipedia</span>

<span class="sd">           - `Greibach normal form</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Greibach_normal_form&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">normalization</span>

        <span class="k">return</span> <span class="n">normalization</span><span class="o">.</span><span class="n">to_gnf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_bcf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if this grammar is in Binary Choice Form (BCF).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_bcf : `bool`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">normalization</span>

        <span class="k">return</span> <span class="n">normalization</span><span class="o">.</span><span class="n">is_bcf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_bcf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert this grammar to Binary Choice Form (BCF).</span>

<span class="sd">        This is my own attempt at modifying a grammar&#39;s form to see</span>
<span class="sd">        if some G3P method can perform better on it.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grammar_in_bnf : `Grammar`</span>
<span class="sd">            New grammar object where all rules adhere to BCF.</span>
<span class="sd">            It is equivalent to the original grammar, which means</span>
<span class="sd">            that it generates the same language.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All nonterminals need to have a maximum of two productions:</span>

<span class="sd">        - ``X → A`` where ``A`` is an arbitrary sequence of symbols</span>
<span class="sd">        - ``X → A | B`` where ``A`` and ``B`` are arbitrary sequences</span>
<span class="sd">          of symbols</span>

<span class="sd">        Tasks that are simplified by having a grammar in BNF:</span>

<span class="sd">        - Grammatical Evolution (GE) can use codons of size 1</span>
<span class="sd">          (=1 bit, 2 possible states) to perform a</span>
<span class="sd">          genotype-to-phenotype mapping, i.e. there is no redundancy</span>
<span class="sd">          in the individual genes and the modulo rule becomes irrelevant.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        I am not aware of literature that introduces such a form.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">normalization</span>

        <span class="k">return</span> <span class="n">normalization</span><span class="o">.</span><span class="n">to_bcf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># Centralized I/O</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a text file and return its content as string.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_handle</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Could not read a grammar from file &quot;</span><span class="si">{}</span><span class="s1">&quot;. &#39;</span>
                <span class="s2">&quot;The file does not exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Could not read a grammar from file &quot;</span><span class="si">{}</span><span class="s1">&quot;. &#39;</span>
                <span class="s2">&quot;The file exists, but reading text from it failed.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_write_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a given string to a text file.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_handle</span><span class="p">:</span>
            <span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># Caching of repeated calculations</span>
    <span class="k">def</span> <span class="nf">_lookup_or_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">calc_func</span><span class="p">,</span> <span class="o">*</span><span class="n">calc_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look up a result in this object&#39;s _cache attribute.</span>

<span class="sd">        If the result is not availabe yet, calculate it once and store</span>
<span class="sd">        it for later reuse.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Cache lookup</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">system</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Calculation</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calc_func</span><span class="p">(</span><span class="o">*</span><span class="n">calc_args</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">system</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">system</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">attribute</span><span class="p">:</span> <span class="n">result</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_calc_sym_idx_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a mapping from a symbol to an index.</span>

<span class="sd">        This is used in this module and in some G3P systems.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">sym</span><span class="p">:</span> <span class="n">num</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">_chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_calc_idx_sym_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a mapping from an index to a symbol.</span>

<span class="sd">        This is used in this module and in some G3P systems.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonterminal_symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_symbols</span><span class="p">))</span></div>


<div class="viewcode-block" id="DerivationTree"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree">[docs]</a><span class="k">class</span> <span class="nc">DerivationTree</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Derivation tree for representing the structure of a string.</span>

<span class="sd">    A **derivation tree** [22]_ is the result from generating or</span>
<span class="sd">    parsing a string with a grammar. For the latter reason,</span>
<span class="sd">    it is also known as **parse tree** [23]_.</span>

<span class="sd">    One **derivation tree** represents a single **string** of the</span>
<span class="sd">    grammar&#39;s language, but multiple **derivations** by which this</span>
<span class="sd">    string can be generated. These derivations differ only in the</span>
<span class="sd">    order in which the nonterminals are expanded, which is not</span>
<span class="sd">    captured by a derivation tree.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Structure:</span>

<span class="sd">    - The tree consists of linked `Node` objects, each of which</span>
<span class="sd">      contains either a `TerminalSymbol` or `NonterminalSymbol`</span>
<span class="sd">      belonging to the grammar.</span>
<span class="sd">    - A rule of a context-free grammar can transform a nonterminal</span>
<span class="sd">      symbol into a sequence of symbols. In a derivation tree this is</span>
<span class="sd">      represented by a node, which contains the nonterminal symbol.</span>
<span class="sd">      This node is connected to one or more child nodes, which are</span>
<span class="sd">      ordered and contain the symbols resulting from the rule</span>
<span class="sd">      application. The parent node is said to be expanded.</span>
<span class="sd">    - The root node of the derivation tree contains the</span>
<span class="sd">      starting symbol of the grammar, which is a `NonterminalSymbol`.</span>
<span class="sd">    - Each internal node of the derivation tree contains a</span>
<span class="sd">      `NonterminalSymbol`.</span>
<span class="sd">    - In a fully expanded derivation tree, where no nonterminal symbol</span>
<span class="sd">      is left that could be further expanded, each leaf node contains</span>
<span class="sd">      a `TerminalSymbol`. Putting the terminal symbols into a sequence</span>
<span class="sd">      results in the string that the derivation tree represents.</span>

<span class="sd">    Behaviour:</span>

<span class="sd">    - A node with a nonterminal can be expanded using a suitable</span>
<span class="sd">      production rule of the grammar.</span>
<span class="sd">    - Depth first traversal allows to get all terminals in correct</span>
<span class="sd">      order. This allows to retrieve the string represented by the</span>
<span class="sd">      derivation tree.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [22] J. E. Hopcroft and J. D. Ullman, Introduction to</span>
<span class="sd">       Automata Theory, Languages and Computation.</span>
<span class="sd">       Addison-Wesley, 1979, pp. 82-87.</span>

<span class="sd">    .. [23] Wikipedia</span>

<span class="sd">       - `Parse tree &lt;https://en.wikipedia.org/wiki/Parse_tree&gt;`__</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;grammar&quot;</span><span class="p">,</span> <span class="s2">&quot;root_node&quot;</span><span class="p">,</span> <span class="s2">&quot;_cache&quot;</span><span class="p">)</span>

    <span class="c1"># Initialization</span>
<div class="viewcode-block" id="DerivationTree.__init__"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">root_symbol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an empty derivation tree with reference to a grammar.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grammar : `Grammar`</span>
<span class="sd">        root_symbol : `Symbol`, optional</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root_symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">grammar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">root_symbol</span> <span class="o">=</span> <span class="n">NonterminalSymbol</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">root_symbol</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start_symbol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">root_symbol</span><span class="p">)</span></div>

    <span class="c1"># Copying</span>
<div class="viewcode-block" id="DerivationTree.copy"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the derivation tree.</span>

<span class="sd">        The new object is entirely independent of the original object.</span>
<span class="sd">        No parts, such as nodes or symbols, are shared between the</span>
<span class="sd">        objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">DerivationTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">)</span>
        <span class="n">dt</span><span class="o">.</span><span class="n">root_node</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># leads to recursive copying of all child nodes</span>
        <span class="k">return</span> <span class="n">dt</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the derivation tree.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/library/copy.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the derivation tree.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/library/copy.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Representations</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;official&quot; string representation of the derivation tree.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__repr__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> object at </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;informal&quot; string representation of the derivation tree.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__str__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_parenthesis_notation</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide rich display representation for Jupyter notebooks.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://ipython.readthedocs.io/en/stable/config/integrating.html#rich-display</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide rich display representation for IPython.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://ipython.readthedocs.io/en/stable/config/integrating.html#rich-display</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="c1"># Equality and hashing</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute whether two derivation trees are equal.</span>

<span class="sd">        This checks if two derivation trees have the same structure</span>
<span class="sd">        and contain the same symbols.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__eq__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Type comparison</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># Data comparison</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">root_node</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">nd1</span><span class="p">,</span> <span class="n">nd2</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nd1</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span> <span class="o">!=</span> <span class="n">nd2</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd1</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">nd2</span><span class="o">.</span><span class="n">children</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">nd1</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="n">nd2</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nd1</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">nd2</span><span class="o">.</span><span class="n">children</span><span class="p">)]</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute whether two derivation trees are not equal.</span>

<span class="sd">        This checks if two derivation trees have a different structure</span>
<span class="sd">        or contain at least one different symbol.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__ne__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Type comparison</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># Data comparison</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">root_node</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">nd1</span><span class="p">,</span> <span class="n">nd2</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nd1</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span> <span class="o">!=</span> <span class="n">nd2</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd1</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">nd2</span><span class="o">.</span><span class="n">children</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">nd1</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="n">nd2</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nd1</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">nd2</span><span class="o">.</span><span class="n">children</span><span class="p">)]</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a hash value for this object.</span>

<span class="sd">        It is used for operations on hashed collections such as `set`</span>
<span class="sd">        and `dict`.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - https://docs.python.org/3/reference/datamodel.html#object.__hash__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">nd</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">+=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ch</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">]</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="c1"># Further representations</span>
<div class="viewcode-block" id="DerivationTree.to_parenthesis_notation"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.to_parenthesis_notation">[docs]</a>    <span class="k">def</span> <span class="nf">to_parenthesis_notation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Represent the tree as string in single-line parenthesis notation.</span>

<span class="sd">        This notation can be found in the Natural Language Toolkit</span>
<span class="sd">        (NLTK) book under the name &quot;bracketed structures&quot; [24]_.</span>
<span class="sd">        There are various similar representations of trees or</span>
<span class="sd">        nested structures [25]_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text : `str`</span>
<span class="sd">            Tree in parenthesis notation.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [24] `NLTK book: Chapter 8</span>
<span class="sd">                &lt;https://www.nltk.org/book/ch08.html&gt;`__</span>

<span class="sd">        .. [25] Wikipedia</span>

<span class="sd">           - `S-expression</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/S-expression&gt;`__</span>

<span class="sd">           - `Newick format</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Newick_format&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">NonterminalSymbol</span><span class="p">):</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
                <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">text</span></div>

<div class="viewcode-block" id="DerivationTree.to_tree_notation"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.to_tree_notation">[docs]</a>    <span class="k">def</span> <span class="nf">to_tree_notation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Represent the tree as string in multi-line tree notation.</span>

<span class="sd">        This notation is a way to represent both code and data in</span>
<span class="sd">        a minimalistic format [26]_ based on newlines and different</span>
<span class="sd">        indentation levels. As such it is also suitable to</span>
<span class="sd">        represent derivation trees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text : `str`</span>
<span class="sd">            Tree in &quot;Tree Notation&quot;.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [26] `Tree Notation &lt;https://treenotation.org&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">NonterminalSymbol</span><span class="p">):</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">depth</span>
            <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">_NEWLINE</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span></div>

    <span class="c1"># Serialization</span>
<div class="viewcode-block" id="DerivationTree.to_tuple"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.to_tuple">[docs]</a>    <span class="k">def</span> <span class="nf">to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Serialize the tree to a tuple.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The data structure is a tuple that contains two other tuples</span>
<span class="sd">        of integers. A depth-first traversal of the tree visits all</span>
<span class="sd">        nodes. For each node, its symbol and number of children is</span>
<span class="sd">        remembered in two separate tuples. Instead of storing the</span>
<span class="sd">        symbols directly, a number is assigned to each symbol of the</span>
<span class="sd">        grammar and that concise number is stored instead of a</span>
<span class="sd">        potentially long symbol text.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        serialized_tree : `tuple` of two `tuple` objects</span>
<span class="sd">            The first tuple describes symbols that are contained</span>
<span class="sd">            in the nodes.</span>
<span class="sd">            The second tuple describes the number of children</span>
<span class="sd">            each node has.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Caching</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">_lookup_or_calc</span><span class="p">(</span>
            <span class="s2">&quot;serialization&quot;</span><span class="p">,</span> <span class="s2">&quot;sym_idx_map&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">_calc_sym_idx_map</span>
        <span class="p">)</span>

        <span class="c1"># Serialization: Traverse nodes in DFS order, remember symbol and number of children</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sym</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sim</span><span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">symbol</span><span class="p">])</span>
            <span class="n">cnt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sym</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span></div>

<div class="viewcode-block" id="DerivationTree.from_tuple"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.from_tuple">[docs]</a>    <span class="k">def</span> <span class="nf">from_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">serialized_tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deserialize the tree from a tuple.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        serialized_tree : `tuple` containing two `tuple` objects</span>
<span class="sd">            The first tuple describes symbols that are contained</span>
<span class="sd">            in the nodes.</span>
<span class="sd">            The second tuple describes the number of children</span>
<span class="sd">            each node has.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Caching</span>
        <span class="n">ism</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">_lookup_or_calc</span><span class="p">(</span>
            <span class="s2">&quot;serialization&quot;</span><span class="p">,</span> <span class="s2">&quot;idx_sym_map&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">_calc_idx_sym_map</span>
        <span class="p">)</span>

        <span class="c1"># Deserialization: Iterate over sequence, add nodes in DFS order, jump when indicated</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">par</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">i</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">ism</span><span class="p">[</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">counters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
            <span class="n">par</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cnt</span><span class="p">):</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>

        <span class="n">symbols</span><span class="p">,</span> <span class="n">counters</span> <span class="o">=</span> <span class="n">serialized_tree</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_node</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">top</span></div>

<div class="viewcode-block" id="DerivationTree.to_json"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Serialize the tree to a JSON string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        json_string : `str`</span>
<span class="sd">            A string in JSON format that represents the tree.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Serialization: Traverse nodes in DFS order, remember symbol, type and number of children</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">is_nt</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">NonterminalSymbol</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">is_nt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">)]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="n">json_string</span> <span class="o">=</span> <span class="n">_json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">separators</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">json_string</span></div>

<div class="viewcode-block" id="DerivationTree.from_json"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.from_json">[docs]</a>    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">serialized_tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deserialize the tree from a JSON string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        serialized_tree : `str`</span>
<span class="sd">            A string in JSON format that represents a tree.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Deserialization: Iterate over sequence, add nodes in DFS order, jump when indicated</span>
        <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">par</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">i</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">text</span><span class="p">,</span> <span class="n">is_nt</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_nt</span><span class="p">:</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">NonterminalSymbol</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">TerminalSymbol</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
            <span class="n">par</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cnt</span><span class="p">):</span>
                <span class="n">traverse</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">_json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">serialized_tree</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_node</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">top</span></div>

    <span class="c1"># Visualization</span>
<div class="viewcode-block" id="DerivationTree.plot"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">show_node_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">layout_engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fontname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">shape_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">shape_unexpanded_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">shape_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fontcolor_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fontcolor_unexpanded_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fontcolor_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fillcolor_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fillcolor_unexpanded_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fillcolor_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the derivation tree as labeled, directed graph.</span>

<span class="sd">        This method uses Graphviz [27]_ and therefore requires it</span>
<span class="sd">        to be installed on the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show_node_indices : `bool`, optional</span>
<span class="sd">            If `True`, nodes will contain numbers that indicate the</span>
<span class="sd">            order in which they were created during tree construction.</span>
<span class="sd">        layout_engine : `str`, optional</span>
<span class="sd">            Layout engine that calculates node positions.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            - ``&quot;circo&quot;``</span>
<span class="sd">            - ``&quot;dot&quot;``</span>
<span class="sd">            - ``&quot;fdp&quot;``</span>
<span class="sd">            - ``&quot;neato&quot;``</span>
<span class="sd">            - ``&quot;osage&quot;``</span>
<span class="sd">            - ``&quot;patchwork&quot;``</span>
<span class="sd">            - ``&quot;sfdp&quot;``</span>
<span class="sd">            - ``&quot;twopi&quot;``</span>
<span class="sd">        fontname : `str`, optional</span>
<span class="sd">            Fontname of text inside nodes.</span>
<span class="sd">        fontsize : `int` or `str`, optional</span>
<span class="sd">            Fontsize of text inside nodes.</span>
<span class="sd">        shape_nt : `str`, optional</span>
<span class="sd">            Shape of nodes that represent expanded nonterminals.</span>

<span class="sd">            Possible values: See `Graphviz documentation: Node shapes</span>
<span class="sd">            &lt;http://www.graphviz.org/doc/info/shapes.html&gt;`__</span>
<span class="sd">        shape_unexpanded_nt : `str`, optional</span>
<span class="sd">            Shape of nodes that represent unexpanded nonterminals.</span>

<span class="sd">            Possible values: See `Graphviz documentation: Node shapes</span>
<span class="sd">            &lt;http://www.graphviz.org/doc/info/shapes.html&gt;`__</span>
<span class="sd">        shape_t : `str`, optional</span>
<span class="sd">            Shape of nodes that represent terminals.</span>

<span class="sd">            Possible values: See `Graphviz documentation: Node shapes</span>
<span class="sd">            &lt;http://www.graphviz.org/doc/info/shapes.html&gt;`__</span>
<span class="sd">        fontcolor_nt : `str`, optional</span>
<span class="sd">            Fontcolor of nodes that represent expanded nonterminals.</span>
<span class="sd">        fontcolor_unexpanded_nt : `str`, optional</span>
<span class="sd">            Fontcolor of nodes that represent unexpanded nonterminals.</span>
<span class="sd">        fontcolor_t : `str`, optional</span>
<span class="sd">            Fontcolor of nodes that represent terminals.</span>
<span class="sd">        fillcolor_nt : `str`, optional</span>
<span class="sd">            Fillcolor of nodes that represent expanded nonterminals.</span>
<span class="sd">        fillcolor_unexpanded_nt : `str`, optional</span>
<span class="sd">            Fillcolor of nodes that represent unexpanded nonterminals.</span>
<span class="sd">        fillcolor_t : `str`, optional</span>
<span class="sd">            Fillcolor of nodes that represent terminals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : `Figure`</span>
<span class="sd">            Figure object containing the plot, allowing to display or</span>
<span class="sd">            export it.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [27]  `Graphviz &lt;https://www.graphviz.org&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">visualization</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">visualization</span><span class="o">.</span><span class="n">create_graphviz_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">show_node_indices</span><span class="p">,</span>
            <span class="n">layout_engine</span><span class="p">,</span>
            <span class="n">fontname</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="p">,</span>
            <span class="n">shape_nt</span><span class="p">,</span>
            <span class="n">shape_unexpanded_nt</span><span class="p">,</span>
            <span class="n">shape_t</span><span class="p">,</span>
            <span class="n">fontcolor_nt</span><span class="p">,</span>
            <span class="n">fontcolor_unexpanded_nt</span><span class="p">,</span>
            <span class="n">fontcolor_t</span><span class="p">,</span>
            <span class="n">fillcolor_nt</span><span class="p">,</span>
            <span class="n">fillcolor_unexpanded_nt</span><span class="p">,</span>
            <span class="n">fillcolor_t</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

    <span class="c1"># Reading contents of the tree</span>
<div class="viewcode-block" id="DerivationTree.nodes"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.nodes">[docs]</a>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;dfs&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all nodes as a list in order of a chosen tree traversal.</span>

<span class="sd">        The nodes in a tree can be visited in different orders with</span>
<span class="sd">        different tree traversal methods [28]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : `str`, optional</span>
<span class="sd">            Possible values:</span>

<span class="sd">            - ``&quot;dfs&quot;``: Traversal in order of a depth-first search</span>
<span class="sd">            - ``&quot;bfs&quot;``: Traversal in order of a breadth-first search</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes : `list` of `Node` objects</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [28] Wikipedia</span>

<span class="sd">           - `Tree traversal &lt;https://en.wikipedia.org/wiki/Tree_traversal&gt;`__</span>
<span class="sd">           - `Depth-first_search &lt;https://en.wikipedia.org/wiki/Depth-first_search&gt;`__</span>
<span class="sd">           - `Breadth-first search &lt;https://en.wikipedia.org/wiki/Breadth-first_search&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Argument processing</span>
        <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;dfs&quot;</span><span class="p">,</span> <span class="s2">&quot;bfs&quot;</span><span class="p">))</span>

        <span class="c1"># Generate node list by tree traversal</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;dfs&quot;</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_depth_first_traversal</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_breadth_first_traversal</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nodes</span></div>

    <span class="k">def</span> <span class="nf">_depth_first_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Traverse the tree with a depth-first search.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes : `list` of `Node` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: List-based implementation is faster than deque and extend(reversed(node.children))</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="k">return</span> <span class="n">nodes</span>

    <span class="k">def</span> <span class="nf">_breadth_first_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Traverse the tree with a breadth-first search.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes : `list` of `Node` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">_collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nodes</span>

<div class="viewcode-block" id="DerivationTree.leaf_nodes"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.leaf_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all leaf nodes by a tree traversal in depth-first order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes : `list` of `Node` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">_collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>  <span class="c1"># LIFO</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># add first child last, so it becomes first</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nodes</span></div>

<div class="viewcode-block" id="DerivationTree.internal_nodes"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.internal_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">internal_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all internal nodes by a tree traversal in depth-first order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes : `list` of `Node` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">_collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>  <span class="c1"># LIFO</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># add first child last, so it becomes first</span>
        <span class="k">return</span> <span class="n">nodes</span></div>

<div class="viewcode-block" id="DerivationTree.tokens"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.tokens">[docs]</a>    <span class="k">def</span> <span class="nf">tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a sequence of tokens in leaf nodes from left to right.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tokens : `list` of `Symbol` objects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()]</span></div>

<div class="viewcode-block" id="DerivationTree.string"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.string">[docs]</a>    <span class="k">def</span> <span class="nf">string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the string contained in the leaf nodes of the tree.</span>

<span class="sd">        - If the tree is fully expanded, no nonterminal symbol is left</span>
<span class="sd">          in the leaf nodes, so the obtained string is composed only of</span>
<span class="sd">          terminals and belongs to the language of the grammar.</span>

<span class="sd">        - If the tree is not fully expanded, the result is not a string</span>
<span class="sd">          but a so called sentential form that still includes</span>
<span class="sd">          nonterminal symbols.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        separator : `str`, optional</span>
<span class="sd">            The separator text used between terminal symbols.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        string : `str`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">TerminalSymbol</span><span class="p">)</span>
            <span class="k">else</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DerivationTree.derivation"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.derivation">[docs]</a>    <span class="k">def</span> <span class="nf">derivation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">derivation_order</span><span class="o">=</span><span class="s2">&quot;leftmost&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a derivation that fits to the structure of the tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        derivation_order : `str`, optional</span>
<span class="sd">            Order in which nonterminals are expanded during the</span>
<span class="sd">            step-by-step derivation.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            - ``&quot;leftmost&quot;``: Expand the leftmost nonterminal</span>
<span class="sd">              in each step.</span>
<span class="sd">            - ``&quot;rightmost&quot;``: Expand the rightmost nonterminal</span>
<span class="sd">              in each step.</span>
<span class="sd">            - ``&quot;random&quot;``: Expand a random nonterminal in each step.</span>
<span class="sd">        newline : `bool`, optional</span>
<span class="sd">            If `True`, the derivation steps are placed on separate</span>
<span class="sd">            lines by adding newline characters between them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        derivation : `str`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Argument processing</span>
        <span class="n">_ap</span><span class="o">.</span><span class="n">str_arg</span><span class="p">(</span>
            <span class="s2">&quot;derivation_order&quot;</span><span class="p">,</span>
            <span class="n">derivation_order</span><span class="p">,</span>
            <span class="n">vals</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;leftmost&quot;</span><span class="p">,</span> <span class="s2">&quot;rightmost&quot;</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">_ap</span><span class="o">.</span><span class="n">bool_arg</span><span class="p">(</span><span class="s2">&quot;newline&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="p">)</span>

        <span class="c1"># Helper functions</span>
        <span class="k">def</span> <span class="nf">next_derivation_step</span><span class="p">(</span><span class="n">derivation</span><span class="p">,</span> <span class="n">old_node</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">):</span>
            <span class="n">last_sentential_form</span> <span class="o">=</span> <span class="n">derivation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_sentential_form</span> <span class="o">=</span> <span class="n">last_sentential_form</span><span class="p">[:]</span>
            <span class="n">insert_idx</span> <span class="o">=</span> <span class="n">last_sentential_form</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">old_node</span><span class="p">)</span>
            <span class="n">new_sentential_form</span><span class="p">[</span><span class="n">insert_idx</span> <span class="p">:</span> <span class="n">insert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_nodes</span>
            <span class="k">if</span> <span class="n">new_sentential_form</span><span class="p">:</span>
                <span class="n">derivation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_sentential_form</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">derivation</span>

        <span class="k">def</span> <span class="nf">symbol_seq_repr</span><span class="p">(</span><span class="n">symbol_seq</span><span class="p">):</span>
            <span class="n">seq_repr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbol_seq</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">NonterminalSymbol</span><span class="p">):</span>
                    <span class="n">seq_repr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sym</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_repr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sym</span><span class="p">))</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq_repr</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">node_seq_repr</span><span class="p">(</span><span class="n">node_seq</span><span class="p">):</span>
            <span class="n">symbol_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_seq</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">symbol_seq_repr</span><span class="p">(</span><span class="n">symbol_seq</span><span class="p">)</span>

        <span class="c1"># Traverse the tree and collect nodes according to the method</span>
        <span class="k">if</span> <span class="n">derivation_order</span> <span class="o">==</span> <span class="s2">&quot;leftmost&quot;</span><span class="p">:</span>
            <span class="n">derivation</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]]</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">nt_node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">derivation</span> <span class="o">=</span> <span class="n">next_derivation_step</span><span class="p">(</span><span class="n">derivation</span><span class="p">,</span> <span class="n">nt_node</span><span class="p">,</span> <span class="n">nt_node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="n">new_nt_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nt_node</span><span class="o">.</span><span class="n">children</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">new_nt_nodes</span> <span class="o">+</span> <span class="n">stack</span>
        <span class="k">elif</span> <span class="n">derivation_order</span> <span class="o">==</span> <span class="s2">&quot;rightmost&quot;</span><span class="p">:</span>
            <span class="n">derivation</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]]</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">nt_node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">derivation</span> <span class="o">=</span> <span class="n">next_derivation_step</span><span class="p">(</span><span class="n">derivation</span><span class="p">,</span> <span class="n">nt_node</span><span class="p">,</span> <span class="n">nt_node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="n">new_nt_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nt_node</span><span class="o">.</span><span class="n">children</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_nt_nodes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">derivation_order</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
            <span class="n">derivation</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]]</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">_random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">nt_node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">derivation</span> <span class="o">=</span> <span class="n">next_derivation_step</span><span class="p">(</span><span class="n">derivation</span><span class="p">,</span> <span class="n">nt_node</span><span class="p">,</span> <span class="n">nt_node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="n">new_nt_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nt_node</span><span class="o">.</span><span class="n">children</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_nt_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newline</span><span class="p">:</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">=&gt; &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_NEWLINE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot; =&gt; &quot;</span>
        <span class="n">derivation_string</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_seq_repr</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">derivation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">derivation_string</span></div>

<div class="viewcode-block" id="DerivationTree.num_expansions"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.num_expansions">[docs]</a>    <span class="k">def</span> <span class="nf">num_expansions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the number of expansions contained in the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        num_expansions : `int`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_expansions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">num_expansions</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="n">stack</span>
        <span class="k">return</span> <span class="n">num_expansions</span></div>

<div class="viewcode-block" id="DerivationTree.num_nodes"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.num_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the number of nodes contained in the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        num_nodes : `int`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">num_nodes</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="n">stack</span>
        <span class="k">return</span> <span class="n">num_nodes</span></div>

<div class="viewcode-block" id="DerivationTree.depth"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the depth of the derivation tree.</span>

<span class="sd">        The depth [29]_ [30]_ [31]_ of a tree is the number of edges</span>
<span class="sd">        in the longest path (in the graph-theoretic sense) from the</span>
<span class="sd">        root node to a leaf node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        depth : `int`</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [29] J. R. Koza, Genetic Programming: On the Programming of</span>
<span class="sd">           Computers by Means of Natural Selection. Cambridge, Mass.:</span>
<span class="sd">           MIT PR, 1992, p. 92.</span>

<span class="sd">           - p. 92: &quot;The depth of a tree is defined as the length of</span>
<span class="sd">             the longest nonbacktracking path from the root to an</span>
<span class="sd">             endpoint.&quot;</span>

<span class="sd">        .. [30] R. Poli, W. B. Langdon, and N. F. McPhee, A Field Guide</span>
<span class="sd">           to Genetic Programming,</span>
<span class="sd">           Morrisville, NC: Lulu Enterprises, UK Ltd, 2008.</span>

<span class="sd">           - p. 12: &quot;The depth of a node is the number of edges that</span>
<span class="sd">             need to be traversed to reach the node starting from the</span>
<span class="sd">             tree’s root node (which is assumed to be at depth 0).</span>
<span class="sd">             The depth of a tree is the depth of its deepest leaf&quot;</span>

<span class="sd">        .. [31] Wikipedia</span>

<span class="sd">           - `Tree (data structure)</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Tree_%28data_structure%29&gt;`__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">md</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">md</span><span class="p">:</span>
                <span class="n">md</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ch</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">]</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="k">return</span> <span class="n">md</span></div>

<div class="viewcode-block" id="DerivationTree.is_completely_expanded"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.DerivationTree.is_completely_expanded">[docs]</a>    <span class="k">def</span> <span class="nf">is_completely_expanded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the tree contains only expanded nonterminal symbols.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_completely_expanded : `bool`</span>
<span class="sd">            If `True`, the tree is fully expanded which means that it</span>
<span class="sd">            contains only terminals in its leave nodes and that it</span>
<span class="sd">            represents complete derivations that lead to a string of</span>
<span class="sd">            the grammar&#39;s language.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_completely_expanded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">contains_unexpanded_nonterminal</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">()):</span>
            <span class="n">is_completely_expanded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">is_completely_expanded</span></div>

    <span class="c1"># Convenience methods for G3P systems</span>
    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">sy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expand a node in the tree by adding child nodes to it.&quot;&quot;&quot;</span>
        <span class="c1"># Syntax minified for minor optimization due to large number of calls</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">append</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sy</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_is_deeper_than</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detect if the derivation tree is deeper than a given value.</span>

<span class="sd">        This method is required by some tree-based G3P systems.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">root_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">stk</span><span class="p">:</span>
            <span class="n">nd</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">stk</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nd</span><span class="o">.</span><span class="n">children</span><span class="p">]</span> <span class="o">+</span> <span class="n">stk</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Node"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Node">[docs]</a><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Node inside a derivation tree.</span>

<span class="sd">    A node contains a symbol and refers to child nodes.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;symbol&quot;</span><span class="p">,</span> <span class="s2">&quot;children&quot;</span><span class="p">)</span>

    <span class="c1"># Initialization</span>
<div class="viewcode-block" id="Node.__init__"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Node.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sy : Symbol</span>
<span class="sd">        ch : `list` of child `Node` objects, optional</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">=</span> <span class="n">sy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ch</span></div>

    <span class="c1"># Copying</span>
<div class="viewcode-block" id="Node.copy"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Node.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the node and its children.&quot;&quot;&quot;</span>
        <span class="c1"># Recursive copy</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the node and its children.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the node and its children.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Representations</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;official&quot; string representation of the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> object at </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;informal&quot; string representation of the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">text</span>

    <span class="c1"># Symbol type requests</span>
<div class="viewcode-block" id="Node.contains_terminal"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Node.contains_terminal">[docs]</a>    <span class="k">def</span> <span class="nf">contains_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the node contains a terminal symbol.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contains_t : `bool`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">TerminalSymbol</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.contains_nonterminal"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Node.contains_nonterminal">[docs]</a>    <span class="k">def</span> <span class="nf">contains_nonterminal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the node contains a nonterminal symbol.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contains_nt : `bool`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">NonterminalSymbol</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.contains_unexpanded_nonterminal"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Node.contains_unexpanded_nonterminal">[docs]</a>    <span class="k">def</span> <span class="nf">contains_unexpanded_nonterminal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the node contains a nonterminal symbol and has no child nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contains_unexpanded_nt : `bool`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">NonterminalSymbol</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Symbol"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Symbol">[docs]</a><span class="k">class</span> <span class="nc">Symbol</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Symbol inside a grammar or derivation tree.</span>

<span class="sd">    A symbol can be either a nonterminal or terminal of the grammar</span>
<span class="sd">    and it has a `text` attribute.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;text&quot;</span><span class="p">,)</span>

    <span class="c1"># Initialization</span>
<div class="viewcode-block" id="Symbol.__init__"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Symbol.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a symbol in the sense of formal language theory.</span>

<span class="sd">        A symbol contains a text that can be empty, a single letter</span>
<span class="sd">        or multiple letters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        text : `str`</span>
<span class="sd">            Text contained in the symbol object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span></div>

    <span class="c1"># Copying</span>
<div class="viewcode-block" id="Symbol.copy"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.Symbol.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a deep copy of the symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># Representations</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;informal&quot; string representation of the symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>

    <span class="c1"># Comparison operators for sorting</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute whether two symbols are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute whether two symbols are not equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute whether a symbol comes before another when ordered.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute __lt__ or __eq__ in one call.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute whether a symbol comes after another when ordered.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute __gt__ or __eq__ in one call.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span>

    <span class="c1"># Hash for usage as dict key</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a hash value for the symbol.</span>

<span class="sd">        It is used for operations on hashed collections such as `set`</span>
<span class="sd">        and `dict`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span></div>


<div class="viewcode-block" id="NonterminalSymbol"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.NonterminalSymbol">[docs]</a><span class="k">class</span> <span class="nc">NonterminalSymbol</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nonterminal symbol inside a grammar or derivation tree.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;official&quot; string representation of the symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;NT(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">))</span></div>


<div class="viewcode-block" id="TerminalSymbol"><a class="viewcode-back" href="../../../autoapi/alogos/_grammar/data_structures/index.html#alogos._grammar.data_structures.TerminalSymbol">[docs]</a><span class="k">class</span> <span class="nc">TerminalSymbol</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Terminal symbol inside a grammar or derivation tree.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the &quot;official&quot; string representation of the symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;T(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">))</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Robert Haas.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>